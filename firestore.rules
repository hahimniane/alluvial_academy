rules_version = '2';

service cloud.firestore {

  match /databases/{database}/documents {

    // Helper function to check if user is authenticated

    function isSignedIn() {

      return request.auth != null;

    }

    

    // Helper function to check if user owns the document

    function isOwner(userId) {

      return isSignedIn() && request.auth.uid == userId;

    }

    

    // Helper to determine if a user record grants admin privileges

    function isAdminRole(data) {

      return data != null && (

        // Normalize string roles to avoid case mismatches ("Admin", "SUPER_ADMIN", etc.)
        ((data.role is string) && (data.role.lower() == 'admin' || data.role.lower() == 'super_admin')) ||

        ((data.user_type is string) &&
          (data.user_type.lower() == 'admin' || data.user_type.lower() == 'super_admin')) ||

        ((data.userType is string) &&
          (data.userType.lower() == 'admin' || data.userType.lower() == 'super_admin')) ||

        data.is_admin == true ||

        data.isAdmin == true ||

        data.is_admin_teacher == true ||

        data.is_super_admin == true ||

        data.isSuperAdmin == true

      );

    }

    

    // Helper function to check if user is admin

    // NOTE: This reads from the users collection, so it cannot be used in the users collection rule

    function isAdmin() {
      return isSignedIn() && (
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && isAdminRole(get(/databases/$(database)/documents/users/$(request.auth.uid)).data)) ||
        // Support deployments where the user document id is the user's email.
        ((request.auth.token.email is string) &&
          exists(/databases/$(database)/documents/users/$(request.auth.token.email.lower())) &&
          isAdminRole(get(/databases/$(database)/documents/users/$(request.auth.token.email.lower())).data)) ||
        ((request.auth.token.email is string) &&
          exists(/databases/$(database)/documents/users/$(request.auth.token.email)) &&
          isAdminRole(get(/databases/$(database)/documents/users/$(request.auth.token.email)).data)) ||
        ((request.auth.token.role is string) &&
          (request.auth.token.role.lower() == 'admin' || request.auth.token.role.lower() == 'super_admin')) ||
        request.auth.token.isAdmin == true ||
        request.auth.token.is_admin == true
      );
    }

    

    // Helper to normalize the authenticated user's email (lowercased)

    function authEmail() {

      return request.auth != null && (request.auth.token.email is string)
        ? request.auth.token.email.lower()
        : '';

    }

    

    // Helper to determine if a user document belongs to the signed-in user (write context)

    function isUserDocOwnerAfterWrite(userId) {

      return isSignedIn() && (

        request.auth.uid == userId ||

        (request.resource.data.uid != null && request.resource.data.uid == request.auth.uid) ||

        ((request.resource.data['e-mail'] is string) && authEmail() != '' && request.resource.data['e-mail'].lower() == authEmail())

      );

    }

    

    // Helper to ensure sensitive fields remain unchanged during updates
    // Returns true if field is unchanged OR if field doesn't exist in both docs

    function fieldUnchanged(fieldName) {
      return (!request.resource.data.keys().hasAny([fieldName]) && !resource.data.keys().hasAny([fieldName])) ||
             (request.resource.data.keys().hasAny([fieldName]) && resource.data.keys().hasAny([fieldName]) && 
              request.resource.data[fieldName] == resource.data[fieldName]);
    }

    

    // Helper to normalize teacherId values stored with different field names

    function teacherIdFromData(data) {

      return data.teacherId != null ? data.teacherId : data.teacher_id;

    }



    // Helper to detect updates affecting only FCM token metadata

    function isFcmTokenOnlyUpdate() {

      return request.resource.data.diff(resource.data).changedKeys()

        .hasOnly(['fcmTokens', 'lastTokenUpdate']);

    }

    

    // Helper to resolve the owner of a form submission across legacy field names

    function submissionOwnerFromData(data) {

      return data.userId != null ? data.userId :

             data.submittedBy != null ? data.submittedBy :

             data.teacherId != null ? data.teacherId :

             data.teacher_id;

    }

    

    // =========================================================================
    // Public Forms (Landing Page)
    // =========================================================================
    
    // Allow anyone to submit an enrollment (create only)
    match /enrollments/{enrollmentId} {
      allow create: if true;
      allow read: if isAdmin();
      allow delete: if isAdmin();
      
      // Allow teachers to update enrollments when accepting a job (setting matched status)
      // OR when withdrawing from a job (resetting to broadcasted)
      allow update: if isAdmin() || (
        isSignedIn() &&
        // Only allow updating metadata fields related to job matching
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['metadata']) &&
        (
          // Case 1: Accepting a job (setting status to 'matched')
          (
            request.resource.data.metadata.status == 'matched' &&
            request.resource.data.metadata.matchedTeacherId == request.auth.uid
          ) ||
          // Case 2: Withdrawing from a job (resetting status to 'broadcasted')
          (
            request.resource.data.metadata.status == 'broadcasted' &&
            resource.data.metadata.matchedTeacherId == request.auth.uid &&
            request.resource.data.metadata.matchedTeacherId == null
          )
        )
      );
    }
    
    // Allow anyone to submit a contact message (create only)
    match /contact_messages/{messageId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }
    
    // Allow anyone to submit a teacher application (create only)
    match /teacher_applications/{applicationId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }

    // =========================================================================
    // Authenticated & Admin Collections
    // =========================================================================

    // Users collection - users can ALWAYS read their own data (no admin check to avoid circular dependency)

    // Admins can read/query all users via explicit role check in the document

    match /users/{userId} {
      // Allow any authenticated user to read any user document (needed for role lookups, email queries, etc.)
      // This is safe because user documents don't contain sensitive data that other users shouldn't see
      allow read: if isSignedIn();

      

      // Allow updates for admins or for users updating their own profile with restricted fields

      allow update: if isAdmin() || (

        isUserDocOwnerAfterWrite(userId) &&

        fieldUnchanged('uid') &&

        fieldUnchanged('user_type') &&

        fieldUnchanged('role') &&

        fieldUnchanged('is_admin_teacher') &&

        fieldUnchanged('is_active') &&

        fieldUnchanged('created_by_admin') &&

	        fieldUnchanged('password_reset_required') &&

	        fieldUnchanged('e-mail') &&

	        fieldUnchanged('deactivated_at') &&

	        fieldUnchanged('deactivated_by_uid') &&

	        fieldUnchanged('deactivated_by_email')

	      ) || (

        isUserDocOwnerAfterWrite(userId) && isFcmTokenOnlyUpdate()

      );

      

      // Allow create/delete operations only for admins

      allow create, delete: if isAdmin();

    }

    

    // Form responses - users can only read their own submissions

    // Admins can read all submissions

    match /form_responses/{responseId} {

      allow read: if isSignedIn() && 

                     (isOwner(submissionOwnerFromData(resource.data)) || isAdmin());

      allow create: if isSignedIn() && 

                       submissionOwnerFromData(request.resource.data) == request.auth.uid;

      allow update, delete: if isAdmin();

    }

    

    // Form templates - all authenticated users can read

    // Only admins can create/update/delete

    match /form/{formId} {

      allow read: if isSignedIn();

      allow write: if isAdmin();

    }

    // Form templates collection (used by FormTemplateService)
    // All authenticated users can read, only admins can write
    match /form_templates/{templateId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    // Form template configuration
    match /form_template_config/{configId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    // Settings collection (used for form template config, app settings, etc.)
    match /settings/{settingId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    

    // Helper to check if teacher owns the shift

    function isShiftOwner(data) {

      return isSignedIn() && (

        // Check teacher_id field (snake_case - what's actually stored in Firestore)

        (data.teacher_id != null && data.teacher_id == request.auth.uid) ||

        (data.teacherId != null && data.teacherId == request.auth.uid) ||

        // Check original_teacher_id for published shifts

        (data.original_teacher_id != null && data.original_teacher_id == request.auth.uid)

      );

    }

    

    // Helper to check if a teacher can claim a published shift

    function canClaimShift() {

      return isSignedIn() &&

        // Check if shift is published and scheduled

        resource.data.is_published == true &&

        resource.data.status == 'scheduled' &&

        // Check if teacher is claiming it (updating teacher_id to their own UID)

        request.resource.data.teacher_id == request.auth.uid &&

        // Check if is_published is being set to false (unpublishing after claim)

        request.resource.data.is_published == false;

    }

    

    // Teaching shifts - teachers can read their own, admins can read/write all

    match /teaching_shifts/{shiftId} {

      // Allow get for any authenticated user (they can list anyway, so this is not a security risk)

      allow get: if isSignedIn();

      // Allow list/query for teachers and admins

      allow list: if isSignedIn();

      // Allow create only for admins

      allow create: if isSignedIn() && isAdmin();

      // Allow update for admins, teachers updating their own shifts, or teachers claiming published shifts

      allow update: if isSignedIn() && (

        isAdmin() || 

        isShiftOwner(resource.data) ||

        canClaimShift()

      );

      // Allow delete only for admins

      allow delete: if isSignedIn() && isAdmin();

    }

    // LiveKit session tracking - authenticated users can read and write join/leave events
    match /livekit_sessions/{sessionId} {
      allow get, list: if isSignedIn();
      allow create, update: if isSignedIn();
      allow delete: if isSignedIn() && isAdmin();
    }

    

    // Timesheet entries - teachers can read/write their own, admins can read/write all

	    match /timesheet_entries/{entryId} {

      // Allow get for specific document

      allow get: if isSignedIn() && 

                    (isAdmin() || teacherIdFromData(resource.data) == request.auth.uid);

      // Allow list/query for teachers to see their own entries

      allow list: if isSignedIn();

      // Allow create if teacher is creating their own entry

      // Check both teacherId and teacher_id fields explicitly

      allow create: if isSignedIn() && (

        (request.resource.data.teacher_id != null && request.resource.data.teacher_id == request.auth.uid) ||

        (request.resource.data.teacherId != null && request.resource.data.teacherId == request.auth.uid) ||

        isAdmin()

      );

      // Allow update/delete for own entries or admin

      // Check both field names explicitly to avoid function call issues

      allow update, delete: if isSignedIn() && (

        (resource.data.teacher_id != null && resource.data.teacher_id == request.auth.uid) ||

        (resource.data.teacherId != null && resource.data.teacherId == request.auth.uid) ||

        isAdmin()

      );

	    }

	    

	    // Assignments - authenticated users can manage their own assignments
	    // Note: Using simple isSignedIn() for create since teacher_id is set client-side
	    // and verified to match auth.uid in the app code

	    match /assignments/{assignmentId} {

	      // Read: User can read if they're the teacher or admin
	      allow read: if isSignedIn();

	      // Create: Any authenticated user can create (app enforces teacher_id = auth.uid)
	      allow create: if isSignedIn();

	      // Update: Owner or admin can update
	      allow update: if isSignedIn() && (
	        isAdmin() ||
	        resource.data.teacher_id == request.auth.uid
	      );

	      // Delete: Owner or admin can delete
	      allow delete: if isSignedIn() && (
	        isAdmin() ||
	        resource.data.teacher_id == request.auth.uid
	      );

	    }

	    

	    // Tasks - users can read tasks assigned to them, admins can read all
	    // Note: Current rule requires user's UID to be in assignedTo array
	    // Parents reading their children's tasks may need Cloud Function or rule adjustment
	    // (since parent UID is not in assignedTo, but child's UID is)
	    match /tasks/{taskId} {

	      allow read: if isSignedIn() && 

                     (request.auth.uid in resource.data.assignedTo || isAdmin());

      allow write: if isAdmin();

    }

    

    // Chat messages - authenticated users can read and write (legacy)

    match /chat_messages/{messageId} {

      allow read, write: if isSignedIn();

    }

    

    // Chat rooms - authenticated users can read and write (legacy)

    match /chat_rooms/{roomId} {

      allow read, write: if isSignedIn();

    }

    
    // Chats collection - role-based access control
    // Users can only read chats they are participants in
    // Permission validation is done server-side via Cloud Functions
    match /chats/{chatId} {
      // Allow read/list for authenticated users
      // The query filters by participants on the client side
      allow read: if isSignedIn();
      
      // Allow create if user is creating a chat they're a participant in
      allow create: if isSignedIn() && 
                       request.auth.uid in request.resource.data.participants;
      
      // Allow update if user is a participant (for last_message updates)
      allow update: if isSignedIn() && 
                       request.auth.uid in resource.data.participants;
      
      // Allow delete only for admins
      allow delete: if isAdmin();
      
      // Messages subcollection
      match /messages/{messageId} {
        // Allow read for participants
        allow read: if isSignedIn();
        
        // Allow create if user is sending as themselves
        allow create: if isSignedIn() && 
                         request.resource.data.sender_id == request.auth.uid;
        
        // Allow update for marking messages as read
        allow update: if isSignedIn();
        
        // No delete allowed (preserve chat history for compliance)
        allow delete: if false;
      }
    }
    
    // No-show reports - authenticated users can create, admins can read/update
    match /no_show_reports/{reportId} {
      allow read: if isAdmin();
      allow create: if isSignedIn();
      allow update, delete: if isAdmin();
    }

    

    // Landing page content - public read, admin write

    match /landing_page_content/{docId} {

      allow read: if true; // Public

      allow write: if isAdmin();

    }

    

    // Website content - public read, admin write

    match /website_content/{docId} {

      allow read: if true; // Public

      allow write: if isAdmin();

    }

    

    // Notifications - users can read their own notifications

    match /notifications/{notificationId} {

      allow read: if isSignedIn() && 

                     (isOwner(resource.data.userId) || isAdmin());

      allow write: if isAdmin();

    }

    
    // Admin Notifications - admins can read/write, teachers can create when accepting jobs

    match /admin_notifications/{notificationId} {

      allow read: if isAdmin();

      allow create: if isSignedIn(); // Teachers can create notifications when accepting jobs

      allow update, delete: if isAdmin();

    }

    
    // Job Board - authenticated users can read jobs, teachers can accept/withdraw from them

    match /job_board/{jobId} {

      // Allow all authenticated users to read jobs (teachers need to see available opportunities)

      allow read: if isSignedIn();

      // Allow admins to create/update/delete

      allow create, delete: if isAdmin();

      // Allow teachers to accept jobs (open -> accepted) OR withdraw from jobs (accepted -> open)

      allow update: if isSignedIn() && (

        isAdmin() ||

        (

          // Case 1: Accepting a job (open -> accepted)
          (
            resource.data.status == 'open' &&
            request.resource.data.status == 'accepted' &&
            request.resource.data.acceptedByTeacherId == request.auth.uid &&
            request.resource.data.enrollmentId == resource.data.enrollmentId
          ) ||
          // Case 2: Withdrawing from a job (accepted -> open)
          (
            resource.data.status == 'accepted' &&
            resource.data.acceptedByTeacherId == request.auth.uid &&
            request.resource.data.status == 'open' &&
            request.resource.data.acceptedByTeacherId == null &&
            request.resource.data.enrollmentId == resource.data.enrollmentId
          )

        )

      );

    }

    
    // Teacher Profiles - teachers can read/write their own, admins can read/write all
    match /teacher_profiles/{profileId} {
      allow read, write: if isSignedIn() && (isOwner(profileId) || isAdmin());
    }

    // Zoom Hosts - admin only (for multi-host meeting distribution)
    // Contains Zoom host account emails used for creating meetings
    match /zoom_hosts/{hostId} {
      allow read, write: if isAdmin();
    }

    // Audit Metrics - teachers can read their own, admins can read/write all
    match /audit_metrics/{metricId} {
      allow read: if isSignedIn() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow write: if isAdmin();
    }

    // Pilot Audit Metrics - teachers can read their own, admins can read/write all
    match /pilot_audit_metrics/{metricId} {
      allow read: if isSignedIn() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow write: if isAdmin();
    }
    // Debug logs - users can read/write their own debug logs
    match /debug_logs/{userId} {
      allow read, write: if isSignedIn() && request.auth.uid == userId;
      
      // Subcollections under debug_logs
      match /{subcollection=**} {
        allow read, write: if isSignedIn() && request.auth.uid == userId;
      }
    }

    // Invoices - parents can read their own, admins can read/write all
    match /invoices/{invoiceId} {
      allow read: if isSignedIn() && 
                     (resource.data.parent_id == request.auth.uid || isAdmin());
      
      allow create: if isAdmin();
      
      allow update: if isAdmin() || 
                       (isSignedIn() && 
                        resource.data.parent_id == request.auth.uid &&
                        // Parents can only update payment_method_id field
                        request.resource.data.diff(resource.data).changedKeys().hasOnly(['payment_method_id']));
      
      allow delete: if isAdmin();
    }

    // Payments - parents can read their own, only Cloud Functions create/update
    match /payments/{paymentId} {
      allow read: if isSignedIn() && 
                     (resource.data.parent_id == request.auth.uid || isAdmin());
      
      // Only Cloud Functions can create/update payments (client-side blocked)
      allow create, update: if false;
      
      allow delete: if isAdmin();
    }

    // Payment methods - parents manage their own subcollection
    match /users/{userId}/payment_methods/{methodId} {
      allow read, write: if isSignedIn() && request.auth.uid == userId;
    }

    // App settings (global feature flags/config) - readable by authenticated users.
    match /app_settings/{docId} {
      allow read: if isSignedIn() && docId == 'global';
      allow write: if isAdmin() && docId == 'global';
    }

    // All other collections - admin only (fallback rule)
    match /{document=**} {
      allow read, write: if isAdmin();
    }

  }

}
