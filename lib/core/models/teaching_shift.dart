import 'package:cloud_firestore/cloud_firestore.dart';

enum ShiftStatus {
  scheduled,
  active,
  completed,
  missed,
  cancelled,
}

enum IslamicSubject {
  quranStudies,
  hadithStudies,
  fiqh,
  arabicLanguage,
  islamicHistory,
  aqeedah,
  tafseer,
  seerah,
}

enum RecurrencePattern {
  none,
  daily,
  weekly,
  monthly,
}

class TeachingShift {
  final String id;
  final String teacherId;
  final String teacherName;
  final List<String> studentIds;
  final List<String> studentNames;
  final DateTime shiftStart;
  final DateTime shiftEnd;
  final String adminTimezone;
  final String teacherTimezone;
  final IslamicSubject subject;
  final String autoGeneratedName;
  final String? customName;
  final double hourlyRate;
  final ShiftStatus status;
  final String createdByAdminId;
  final DateTime createdAt;
  final DateTime? lastModified;
  final RecurrencePattern recurrence;
  final DateTime? recurrenceEndDate;
  final Map<String, dynamic>? recurrenceSettings;
  final String? notes;

  // Clock-in/out tracking fields
  final DateTime? clockInTime;
  final DateTime? clockOutTime;
  final bool isManualOverride; // For admin manual adjustments

  TeachingShift({
    required this.id,
    required this.teacherId,
    required this.teacherName,
    required this.studentIds,
    required this.studentNames,
    required this.shiftStart,
    required this.shiftEnd,
    required this.adminTimezone,
    required this.teacherTimezone,
    required this.subject,
    required this.autoGeneratedName,
    this.customName,
    required this.hourlyRate,
    required this.status,
    required this.createdByAdminId,
    required this.createdAt,
    this.lastModified,
    this.recurrence = RecurrencePattern.none,
    this.recurrenceEndDate,
    this.recurrenceSettings,
    this.notes,
    this.clockInTime,
    this.clockOutTime,
    this.isManualOverride = false,
  });

  // Get the display name (custom name takes priority over auto-generated)
  String get displayName => customName ?? autoGeneratedName;

  // Get shift duration in hours
  double get shiftDurationHours {
    return shiftEnd.difference(shiftStart).inMinutes / 60.0;
  }

  // Calculate total payment for this shift
  double get totalPayment {
    return shiftDurationHours * hourlyRate;
  }

  // Get subject display name
  String get subjectDisplayName {
    switch (subject) {
      case IslamicSubject.quranStudies:
        return 'Quran Studies';
      case IslamicSubject.hadithStudies:
        return 'Hadith Studies';
      case IslamicSubject.fiqh:
        return 'Islamic Jurisprudence (Fiqh)';
      case IslamicSubject.arabicLanguage:
        return 'Arabic Language';
      case IslamicSubject.islamicHistory:
        return 'Islamic History';
      case IslamicSubject.aqeedah:
        return 'Islamic Creed (Aqeedah)';
      case IslamicSubject.tafseer:
        return 'Quran Interpretation (Tafseer)';
      case IslamicSubject.seerah:
        return 'Prophet\'s Biography (Seerah)';
    }
  }

  // Check if teacher can clock in (15 minutes before shift)
  bool get canClockIn {
    final now = DateTime.now();
    // Convert shift times to local timezone for comparison
    final shiftStartLocal = shiftStart.toLocal();
    final shiftEndLocal = shiftEnd.toLocal();
    final clockInWindow = shiftStartLocal.subtract(const Duration(minutes: 15));
    return now.isAfter(clockInWindow) &&
        now.isBefore(shiftEndLocal.add(const Duration(minutes: 15)));
  }

  // Check if shift is currently active
  bool get isCurrentlyActive {
    final now = DateTime.now();
    final shiftStartLocal = shiftStart.toLocal();
    final shiftEndLocal = shiftEnd.toLocal();
    return now.isAfter(shiftStartLocal) && now.isBefore(shiftEndLocal);
  }

  // Check if shift has expired (15 minutes after end)
  bool get hasExpired {
    final now = DateTime.now();
    final shiftEndLocal = shiftEnd.toLocal();
    final expiredTime = shiftEndLocal.add(const Duration(minutes: 15));
    return now.isAfter(expiredTime);
  }

  // Check if teacher is currently clocked in
  bool get isClockedIn {
    return clockInTime != null &&
        clockOutTime == null &&
        status == ShiftStatus.active;
  }

  // Check if teacher can clock out
  bool get canClockOut {
    return isClockedIn && !hasExpired;
  }

  // Check if shift needs auto-logout (clocked in but expired)
  bool get needsAutoLogout {
    return isClockedIn && hasExpired;
  }

  // Get actual shift duration based on clock-in/out times
  Duration? get actualShiftDuration {
    if (clockInTime != null && clockOutTime != null) {
      return clockOutTime!.difference(clockInTime!);
    }
    return null;
  }

  // Get actual shift duration in hours for payment calculation
  double? get actualShiftDurationHours {
    final duration = actualShiftDuration;
    return duration != null ? duration.inMinutes / 60.0 : null;
  }

  // Calculate payment based on actual worked hours (if clocked out) or scheduled hours
  double get actualPayment {
    final actualHours = actualShiftDurationHours;
    return actualHours != null ? actualHours * hourlyRate : totalPayment;
  }

  // Get clock-in window start time (15 minutes before shift)
  DateTime get clockInWindowStart {
    return shiftStart.toLocal().subtract(const Duration(minutes: 15));
  }

  // Get clock-out deadline (15 minutes after shift end)
  DateTime get clockOutDeadline {
    return shiftEnd.toLocal().add(const Duration(minutes: 15));
  }

  // Generate automatic name based on teacher, subject, and students
  static String generateAutoName({
    required String teacherName,
    required IslamicSubject subject,
    required List<String> studentNames,
  }) {
    String subjectName = _getSubjectShortName(subject);

    if (studentNames.isEmpty) {
      return '$teacherName - $subjectName';
    } else if (studentNames.length == 1) {
      return '$teacherName - $subjectName - ${studentNames[0]}';
    } else if (studentNames.length <= 3) {
      return '$teacherName - $subjectName - ${studentNames.join(', ')}';
    } else {
      return '$teacherName - $subjectName - ${studentNames.take(2).join(', ')} +${studentNames.length - 2} more';
    }
  }

  static String _getSubjectShortName(IslamicSubject subject) {
    switch (subject) {
      case IslamicSubject.quranStudies:
        return 'Quran';
      case IslamicSubject.hadithStudies:
        return 'Hadith';
      case IslamicSubject.fiqh:
        return 'Fiqh';
      case IslamicSubject.arabicLanguage:
        return 'Arabic';
      case IslamicSubject.islamicHistory:
        return 'History';
      case IslamicSubject.aqeedah:
        return 'Aqeedah';
      case IslamicSubject.tafseer:
        return 'Tafseer';
      case IslamicSubject.seerah:
        return 'Seerah';
    }
  }

  // Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'teacher_id': teacherId,
      'teacher_name': teacherName,
      'student_ids': studentIds,
      'student_names': studentNames,
      'shift_start': Timestamp.fromDate(shiftStart),
      'shift_end': Timestamp.fromDate(shiftEnd),
      'admin_timezone': adminTimezone,
      'teacher_timezone': teacherTimezone,
      'subject': subject.name,
      'auto_generated_name': autoGeneratedName,
      'custom_name': customName,
      'hourly_rate': hourlyRate,
      'status': status.name,
      'created_by_admin_id': createdByAdminId,
      'created_at': Timestamp.fromDate(createdAt),
      'last_modified':
          lastModified != null ? Timestamp.fromDate(lastModified!) : null,
      'recurrence': recurrence.name,
      'recurrence_end_date': recurrenceEndDate != null
          ? Timestamp.fromDate(recurrenceEndDate!)
          : null,
      'recurrence_settings': recurrenceSettings,
      'notes': notes,
      'clock_in_time':
          clockInTime != null ? Timestamp.fromDate(clockInTime!) : null,
      'clock_out_time':
          clockOutTime != null ? Timestamp.fromDate(clockOutTime!) : null,
      'is_manual_override': isManualOverride,
    };
  }

  // Create from Firestore document
  factory TeachingShift.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    return TeachingShift(
      id: data['id'] ?? doc.id,
      teacherId: data['teacher_id'] ?? '',
      teacherName: data['teacher_name'] ?? '',
      studentIds: List<String>.from(data['student_ids'] ?? []),
      studentNames: List<String>.from(data['student_names'] ?? []),
      shiftStart: (data['shift_start'] as Timestamp).toDate(),
      shiftEnd: (data['shift_end'] as Timestamp).toDate(),
      adminTimezone: data['admin_timezone'] ?? 'UTC',
      teacherTimezone: data['teacher_timezone'] ?? 'UTC',
      subject: IslamicSubject.values.firstWhere(
        (e) => e.name == data['subject'],
        orElse: () => IslamicSubject.quranStudies,
      ),
      autoGeneratedName: data['auto_generated_name'] ?? '',
      customName: data['custom_name'],
      hourlyRate: (data['hourly_rate'] ?? 0.0).toDouble(),
      status: ShiftStatus.values.firstWhere(
        (e) => e.name == data['status'],
        orElse: () => ShiftStatus.scheduled,
      ),
      createdByAdminId: data['created_by_admin_id'] ?? '',
      createdAt: (data['created_at'] as Timestamp).toDate(),
      lastModified: data['last_modified'] != null
          ? (data['last_modified'] as Timestamp).toDate()
          : null,
      recurrence: RecurrencePattern.values.firstWhere(
        (e) => e.name == data['recurrence'],
        orElse: () => RecurrencePattern.none,
      ),
      recurrenceEndDate: data['recurrence_end_date'] != null
          ? (data['recurrence_end_date'] as Timestamp).toDate()
          : null,
      recurrenceSettings: data['recurrence_settings'],
      notes: data['notes'],
      clockInTime: data['clock_in_time'] != null
          ? (data['clock_in_time'] as Timestamp).toDate()
          : null,
      clockOutTime: data['clock_out_time'] != null
          ? (data['clock_out_time'] as Timestamp).toDate()
          : null,
      isManualOverride: data['is_manual_override'] ?? false,
    );
  }

  // Create a copy with updated fields
  TeachingShift copyWith({
    String? id,
    String? teacherId,
    String? teacherName,
    List<String>? studentIds,
    List<String>? studentNames,
    DateTime? shiftStart,
    DateTime? shiftEnd,
    String? adminTimezone,
    String? teacherTimezone,
    IslamicSubject? subject,
    String? autoGeneratedName,
    String? customName,
    double? hourlyRate,
    ShiftStatus? status,
    String? createdByAdminId,
    DateTime? createdAt,
    DateTime? lastModified,
    RecurrencePattern? recurrence,
    DateTime? recurrenceEndDate,
    Map<String, dynamic>? recurrenceSettings,
    String? notes,
    DateTime? clockInTime,
    DateTime? clockOutTime,
    bool? isManualOverride,
  }) {
    return TeachingShift(
      id: id ?? this.id,
      teacherId: teacherId ?? this.teacherId,
      teacherName: teacherName ?? this.teacherName,
      studentIds: studentIds ?? this.studentIds,
      studentNames: studentNames ?? this.studentNames,
      shiftStart: shiftStart ?? this.shiftStart,
      shiftEnd: shiftEnd ?? this.shiftEnd,
      adminTimezone: adminTimezone ?? this.adminTimezone,
      teacherTimezone: teacherTimezone ?? this.teacherTimezone,
      subject: subject ?? this.subject,
      autoGeneratedName: autoGeneratedName ?? this.autoGeneratedName,
      customName: customName ?? this.customName,
      hourlyRate: hourlyRate ?? this.hourlyRate,
      status: status ?? this.status,
      createdByAdminId: createdByAdminId ?? this.createdByAdminId,
      createdAt: createdAt ?? this.createdAt,
      lastModified: lastModified ?? DateTime.now(),
      recurrence: recurrence ?? this.recurrence,
      recurrenceEndDate: recurrenceEndDate ?? this.recurrenceEndDate,
      recurrenceSettings: recurrenceSettings ?? this.recurrenceSettings,
      notes: notes ?? this.notes,
      clockInTime: clockInTime ?? this.clockInTime,
      clockOutTime: clockOutTime ?? this.clockOutTime,
      isManualOverride: isManualOverride ?? this.isManualOverride,
    );
  }
}
