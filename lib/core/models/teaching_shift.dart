import 'package:cloud_firestore/cloud_firestore.dart';
import 'enhanced_recurrence.dart';
import '../enums/shift_enums.dart';

class TeachingShift {
  // No grace period - shifts are marked as missed immediately after end time
  // static const Duration clockInGracePeriod = Duration(minutes: 15); // REMOVED - handled by backend

  final String id;
  final String teacherId;
  final String teacherName;
  final List<String> studentIds;
  final List<String> studentNames;
  final DateTime shiftStart;
  final DateTime shiftEnd;
  final String adminTimezone;
  final String teacherTimezone;
  final IslamicSubject subject; // Legacy field for backward compatibility
  final String? subjectId; // New field for dynamic subjects
  final String?
      subjectDisplayName; // Cache subject display name for performance
  final String autoGeneratedName;
  final String? customName;
  final double hourlyRate;
  final ShiftStatus status;
  final String createdByAdminId;
  final DateTime createdAt;
  final DateTime? lastModified;
  final RecurrencePattern recurrence; // Keep for backward compatibility
  final DateTime? recurrenceEndDate;
  final Map<String, dynamic>? recurrenceSettings;
  final EnhancedRecurrence enhancedRecurrence; // New enhanced recurrence
  final String? notes;

  // Clock-in/out tracking fields
  final DateTime? clockInTime;
  final DateTime? clockOutTime;
  final bool isManualOverride; // For admin manual adjustments
  final String?
      lastClockInPlatform; // Platform used for last clock-in (web, android, ios)
  final DateTime? activatedAt; // When the shift window officially opened
  final bool autoClockOut; // Whether the system performed clock-out
  final String? autoClockOutReason; // Reason for system clock-out
  final String?
      completionState; // human-readable completion summary (e.g. partial/full)
  final int? workedMinutes; // Total minutes worked across timesheets

  // Shift publishing fields (for teacher shift sharing)
  final bool isPublished; // Whether the shift is published for other teachers
  final String? publishedBy; // User ID of the teacher who published it
  final DateTime? publishedAt; // When the shift was published
  final String?
      originalTeacherId; // Original teacher ID (preserved when claimed)
  final String?
      originalTeacherName; // Original teacher name (preserved when claimed)

  // Shift category and leader role fields
  final ShiftCategory
      category; // Distinguishes teaching vs leadership schedules
  final String?
      leaderRole; // Role for leader shifts (admin, coordination, meeting, etc.)

  // Zoom meeting fields (populated by backend when meeting is created)
  final String? zoomMeetingId;
  final String? zoomEncryptedJoinUrl;
  final DateTime? zoomMeetingCreatedAt;
  final DateTime? zoomInviteSentAt;

  // Hub Meeting Fields
  final String? hubMeetingId;
  final String? breakoutRoomName;
  final String? breakoutRoomKey;
  final String? zoomRoutingMode; // "preassign", "selfselect", "hybrid"

  // Routing Risk Fields (for Zoom breakout pre-assignment)
  final List<Map<String, dynamic>> routingRiskParticipants;
  final List<String> preAssignedParticipants;
  final bool hasRoutingRisk;

  TeachingShift({
    required this.id,
    required this.teacherId,
    required this.teacherName,
    required this.studentIds,
    required this.studentNames,
    required this.shiftStart,
    required this.shiftEnd,
    required this.adminTimezone,
    required this.teacherTimezone,
    required this.subject,
    this.subjectId,
    this.subjectDisplayName,
    required this.autoGeneratedName,
    this.customName,
    required this.hourlyRate,
    required this.status,
    required this.createdByAdminId,
    required this.createdAt,
    this.lastModified,
    this.recurrence = RecurrencePattern.none,
    this.recurrenceEndDate,
    this.recurrenceSettings,
    this.enhancedRecurrence = const EnhancedRecurrence(),
    this.notes,
    this.clockInTime,
    this.clockOutTime,
    this.isManualOverride = false,
    this.lastClockInPlatform,
    this.activatedAt,
    this.autoClockOut = false,
    this.autoClockOutReason,
    this.completionState,
    this.workedMinutes,
    this.isPublished = false,
    this.publishedBy,
    this.publishedAt,
    this.originalTeacherId,
    this.originalTeacherName,
    this.category = ShiftCategory.teaching,
    this.leaderRole,
    this.zoomMeetingId,
    this.zoomEncryptedJoinUrl,
    this.zoomMeetingCreatedAt,
    this.zoomInviteSentAt,
    this.hubMeetingId,
    this.breakoutRoomName,
    this.breakoutRoomKey,
    this.zoomRoutingMode,
    this.routingRiskParticipants = const [],
    this.preAssignedParticipants = const [],
    this.hasRoutingRisk = false,
  });

  // Check if shift has a Zoom meeting configured (direct OR hub)
  bool get hasZoomMeeting =>
      (zoomMeetingId != null && zoomMeetingId!.isNotEmpty) ||
      (hubMeetingId != null && hubMeetingId!.isNotEmpty);

  // Get the display name (custom name takes priority over auto-generated)
  String get displayName => customName ?? autoGeneratedName;

  // Get shift duration in hours
  double get shiftDurationHours {
    return shiftEnd.difference(shiftStart).inMinutes / 60.0;
  }

  int get scheduledDurationMinutes {
    return shiftEnd.difference(shiftStart).inMinutes;
  }

  bool get hasWorked => (workedMinutes ?? 0) > 0;

  bool get hasWorkedFull =>
      workedMinutes != null && workedMinutes! >= scheduledDurationMinutes;

  bool get hasWorkedPartially =>
      workedMinutes != null &&
      workedMinutes! > 0 &&
      workedMinutes! < scheduledDurationMinutes;

  double? get workedRatio {
    if (workedMinutes == null) return null;
    final sched = scheduledDurationMinutes;
    if (sched <= 0) return null;
    return workedMinutes! / sched;
  }

  ShiftStatus deriveCompletionStatus({int toleranceMinutes = 1}) {
    if (!hasWorked) {
      return ShiftStatus.missed;
    }
    final sched = scheduledDurationMinutes;
    if (workedMinutes != null && workedMinutes! + toleranceMinutes >= sched) {
      return ShiftStatus.fullyCompleted;
    }
    return ShiftStatus.partiallyCompleted;
  }

  // Calculate total payment for this shift
  double get totalPayment {
    return shiftDurationHours * hourlyRate;
  }

  // Get subject display name - use cached value if available, otherwise fallback to enum
  String get effectiveSubjectDisplayName {
    // Use the cached display name if available (for dynamic subjects)
    if (subjectDisplayName != null && subjectDisplayName!.isNotEmpty) {
      return subjectDisplayName!;
    }

    // Otherwise, fallback to enum-based display name
    switch (subject) {
      case IslamicSubject.quranStudies:
        return 'Quran Studies';
      case IslamicSubject.hadithStudies:
        return 'Hadith Studies';
      case IslamicSubject.fiqh:
        return 'Islamic Jurisprudence (Fiqh)';
      case IslamicSubject.arabicLanguage:
        return 'Arabic Language';
      case IslamicSubject.islamicHistory:
        return 'Islamic History';
      case IslamicSubject.aqeedah:
        return 'Islamic Creed (Aqeedah)';
      case IslamicSubject.tafseer:
        return 'Quran Interpretation (Tafseer)';
      case IslamicSubject.seerah:
        return 'Prophet\'s Biography (Seerah)';
    }
  }

  // Check if teacher can clock in (1 minute before shift start until shift end)
  bool get canClockIn {
    final nowUtc = DateTime.now().toUtc();
    final shiftStartUtc = shiftStart.toUtc();
    final shiftEndUtc = shiftEnd.toUtc();
    
    // Allow clock-in 1 minute before shift start
    final clockInWindowStartUtc = shiftStartUtc.subtract(const Duration(minutes: 1));

    final isOnOrAfterWindowStart = !nowUtc.isBefore(clockInWindowStartUtc);
    final isOnOrBeforeEnd = !nowUtc.isAfter(shiftEndUtc);

    return isOnOrAfterWindowStart && isOnOrBeforeEnd;
  }

  // Check if shift is currently active
  bool get isCurrentlyActive {
    final nowUtc = DateTime.now().toUtc();
    // Compare in UTC to ensure timezone consistency
    final shiftStartUtc = shiftStart.toUtc();
    final shiftEndUtc = shiftEnd.toUtc();
    return nowUtc.isAfter(shiftStartUtc) && nowUtc.isBefore(shiftEndUtc);
  }

  // Check if shift has expired (immediately after end time, no grace period)
  bool get hasExpired {
    final nowUtc = DateTime.now().toUtc();
    // Compare in UTC to ensure timezone consistency
    final shiftEndUtc = shiftEnd.toUtc();
    // No grace period - expires immediately when shift ends
    return nowUtc.isAfter(shiftEndUtc);
  }

  // Check if teacher is currently clocked in
  bool get isClockedIn {
    return clockInTime != null &&
        clockOutTime == null &&
        status == ShiftStatus.active;
  }

  // Check if teacher can clock out
  bool get canClockOut {
    return isClockedIn && !hasExpired;
  }

  // Check if shift needs auto-logout (clocked in but expired)
  bool get needsAutoLogout {
    return isClockedIn && hasExpired;
  }

  // Clock-in deadline is the shift end time (no grace period)
  // Backend monitoring handles missed shift detection
  @Deprecated('Grace period removed - use shift end time directly')
  DateTime clockInGraceDeadline({DateTime? nextShiftStartUtc}) {
    // Grace period has been removed to simplify logic
    // Shifts are marked as missed immediately after end time
    return shiftEnd.toUtc();
  }

  // Check if shift should be marked as missed
  // Shift is missed if it has ended and teacher never clocked in
  // This is now handled by backend cloud function to avoid timezone issues
  @Deprecated('Use backend monitoring instead')
  bool shouldBeMarkedAsMissed({
    DateTime? nowUtcOverride,
    DateTime? nextShiftStartUtc,
  }) {
    // This method is deprecated - shift status monitoring is now handled
    // by the backend cloud function (monitorShiftStatuses) to ensure
    // consistent UTC-based checking and avoid timezone issues
    return false;
  }

  // Get actual shift duration based on clock-in/out times
  Duration? get actualShiftDuration {
    if (clockInTime != null && clockOutTime != null) {
      return clockOutTime!.difference(clockInTime!);
    }
    return null;
  }

  // Get actual shift duration in hours for payment calculation
  double? get actualShiftDurationHours {
    final duration = actualShiftDuration;
    return duration != null ? duration.inMinutes / 60.0 : null;
  }

  // Calculate payment based on actual worked hours (if clocked out) or scheduled hours
  double get actualPayment {
    final actualHours = actualShiftDurationHours;
    return actualHours != null ? actualHours * hourlyRate : totalPayment;
  }

  // Get clock-in window start time (exact shift start, no grace)
  DateTime get clockInWindowStart {
    // Use UTC for consistency
    return shiftStart.toUtc();
  }

  // Get clock-out deadline (exact shift end, no grace period)
  DateTime get clockOutDeadline {
    // Use UTC for consistency
    return shiftEnd.toUtc();
  }

  // Generate automatic name based on teacher, subject, and students
  static String generateAutoName({
    required String teacherName,
    required IslamicSubject subject,
    required List<String> studentNames,
  }) {
    String subjectName = _getSubjectShortName(subject);

    if (studentNames.isEmpty) {
      return '$teacherName - $subjectName';
    } else if (studentNames.length == 1) {
      return '$teacherName - $subjectName - ${studentNames[0]}';
    } else if (studentNames.length <= 3) {
      return '$teacherName - $subjectName - ${studentNames.join(', ')}';
    } else {
      return '$teacherName - $subjectName - ${studentNames.take(2).join(', ')} +${studentNames.length - 2} more';
    }
  }

  static String _getSubjectShortName(IslamicSubject subject) {
    switch (subject) {
      case IslamicSubject.quranStudies:
        return 'Quran';
      case IslamicSubject.hadithStudies:
        return 'Hadith';
      case IslamicSubject.fiqh:
        return 'Fiqh';
      case IslamicSubject.arabicLanguage:
        return 'Arabic';
      case IslamicSubject.islamicHistory:
        return 'History';
      case IslamicSubject.aqeedah:
        return 'Aqeedah';
      case IslamicSubject.tafseer:
        return 'Tafseer';
      case IslamicSubject.seerah:
        return 'Seerah';
    }
  }

  // Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'teacher_id': teacherId,
      'teacher_name': teacherName,
      'student_ids': studentIds,
      'student_names': studentNames,
      'shift_start': Timestamp.fromDate(shiftStart),
      'shift_end': Timestamp.fromDate(shiftEnd),
      'admin_timezone': adminTimezone,
      'teacher_timezone': teacherTimezone,
      'subject': subject.name,
      'subject_id': subjectId,
      'subject_display_name': subjectDisplayName,
      'auto_generated_name': autoGeneratedName,
      'custom_name': customName,
      'hourly_rate': hourlyRate,
      'status': status.name,
      'created_by_admin_id': createdByAdminId,
      'created_at': Timestamp.fromDate(createdAt),
      'last_modified':
          lastModified != null ? Timestamp.fromDate(lastModified!) : null,
      'recurrence': recurrence.name,
      'enhanced_recurrence': enhancedRecurrence.toFirestore(),
      'recurrence_end_date': recurrenceEndDate != null
          ? Timestamp.fromDate(recurrenceEndDate!)
          : null,
      'recurrence_settings': recurrenceSettings,
      'notes': notes,
      'clock_in_time':
          clockInTime != null ? Timestamp.fromDate(clockInTime!) : null,
      'clock_out_time':
          clockOutTime != null ? Timestamp.fromDate(clockOutTime!) : null,
      'is_manual_override': isManualOverride,
      'last_clock_in_platform': lastClockInPlatform,
      'activated_at':
          activatedAt != null ? Timestamp.fromDate(activatedAt!) : null,
      'auto_clock_out': autoClockOut,
      'auto_clock_out_reason': autoClockOutReason,
      'completion_state': completionState,
      'worked_minutes': workedMinutes,
      'is_published': isPublished,
      'published_by': publishedBy,
      'published_at':
          publishedAt != null ? Timestamp.fromDate(publishedAt!) : null,
      'original_teacher_id': originalTeacherId,
      'original_teacher_name': originalTeacherName,
      'shift_category': category.name,
      'leader_role': leaderRole,
      'zoom_meeting_id': zoomMeetingId,
      'zoom_encrypted_join_url': zoomEncryptedJoinUrl,
      'zoom_meeting_created_at': zoomMeetingCreatedAt != null
          ? Timestamp.fromDate(zoomMeetingCreatedAt!)
          : null,
      'zoom_invite_sent_at': zoomInviteSentAt != null
          ? Timestamp.fromDate(zoomInviteSentAt!)
          : null,
      'hubMeetingId': hubMeetingId,
      'breakoutRoomName': breakoutRoomName,
      'breakoutRoomKey': breakoutRoomKey,
      'zoomRoutingMode': zoomRoutingMode,
      'routingRiskParticipants': routingRiskParticipants,
      'preAssignedParticipants': preAssignedParticipants,
      'hasRoutingRisk': hasRoutingRisk,
    };
  }

  // Create from Firestore document
  factory TeachingShift.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    return TeachingShift(
      id: data['id'] ?? doc.id,
      teacherId: data['teacher_id'] ?? '',
      teacherName: data['teacher_name'] ?? '',
      studentIds: List<String>.from(data['student_ids'] ?? []),
      studentNames: List<String>.from(data['student_names'] ?? []),
      shiftStart: (data['shift_start'] as Timestamp).toDate(),
      shiftEnd: (data['shift_end'] as Timestamp).toDate(),
      adminTimezone: data['admin_timezone'] ?? 'UTC',
      teacherTimezone: data['teacher_timezone'] ?? 'UTC',
      subject: IslamicSubject.values.firstWhere(
        (e) => e.name == data['subject'],
        orElse: () => IslamicSubject.quranStudies,
      ),
      subjectId: data['subject_id'],
      subjectDisplayName: data['subject_display_name'],
      autoGeneratedName: data['auto_generated_name'] ?? '',
      customName: data['custom_name'],
      hourlyRate: (data['hourly_rate'] ?? 0.0).toDouble(),
      status: ShiftStatus.values.firstWhere(
        (e) => e.name == data['status'],
        orElse: () => ShiftStatus.scheduled,
      ),
      createdByAdminId: data['created_by_admin_id'] ?? '',
      createdAt: (data['created_at'] as Timestamp).toDate(),
      lastModified: data['last_modified'] != null
          ? (data['last_modified'] as Timestamp).toDate()
          : null,
      recurrence: RecurrencePattern.values.firstWhere(
        (e) => e.name == data['recurrence'],
        orElse: () => RecurrencePattern.none,
      ),
      enhancedRecurrence: data['enhanced_recurrence'] != null
          ? EnhancedRecurrence.fromFirestore(
              Map<String, dynamic>.from(data['enhanced_recurrence']))
          : const EnhancedRecurrence(),
      recurrenceEndDate: data['recurrence_end_date'] != null
          ? (data['recurrence_end_date'] as Timestamp).toDate()
          : null,
      recurrenceSettings: data['recurrence_settings'],
      notes: data['notes'],
      clockInTime: data['clock_in_time'] != null
          ? (data['clock_in_time'] as Timestamp).toDate()
          : null,
      clockOutTime: data['clock_out_time'] != null
          ? (data['clock_out_time'] as Timestamp).toDate()
          : null,
      isManualOverride: data['is_manual_override'] ?? false,
      lastClockInPlatform: data['last_clock_in_platform'],
      activatedAt: data['activated_at'] != null
          ? (data['activated_at'] as Timestamp).toDate()
          : null,
      autoClockOut: data['auto_clock_out'] ?? false,
      autoClockOutReason: data['auto_clock_out_reason'],
      completionState: data['completion_state'],
      workedMinutes: data['worked_minutes'],
      isPublished: data['is_published'] ?? false,
      publishedBy: data['published_by'],
      publishedAt: data['published_at'] != null
          ? (data['published_at'] as Timestamp).toDate()
          : null,
      originalTeacherId: data['original_teacher_id'],
      originalTeacherName: data['original_teacher_name'],
      category: ShiftCategory.values.firstWhere(
        (e) => e.name == (data['shift_category'] ?? 'teaching'),
        orElse: () => ShiftCategory.teaching,
      ),
      leaderRole: data['leader_role'],
      zoomMeetingId: data['zoom_meeting_id'],
      zoomEncryptedJoinUrl: data['zoom_encrypted_join_url'],
      zoomMeetingCreatedAt: data['zoom_meeting_created_at'] != null
          ? (data['zoom_meeting_created_at'] as Timestamp).toDate()
          : null,
      zoomInviteSentAt: data['zoom_invite_sent_at'] != null
          ? (data['zoom_invite_sent_at'] as Timestamp).toDate()
          : null,
      hubMeetingId: data['hubMeetingId'],
      breakoutRoomName: data['breakoutRoomName'],
      breakoutRoomKey: data['breakoutRoomKey'],
      zoomRoutingMode: data['zoomRoutingMode'],
      routingRiskParticipants: data['routingRiskParticipants'] != null
          ? List<Map<String, dynamic>>.from(
              (data['routingRiskParticipants'] as List)
                  .map((e) => Map<String, dynamic>.from(e as Map)))
          : const [],
      preAssignedParticipants: data['preAssignedParticipants'] != null
          ? List<String>.from(data['preAssignedParticipants'])
          : const [],
      hasRoutingRisk: data['hasRoutingRisk'] ?? false,
    );
  }

  // Create a copy with updated fields
  TeachingShift copyWith({
    String? id,
    String? teacherId,
    String? teacherName,
    List<String>? studentIds,
    List<String>? studentNames,
    DateTime? shiftStart,
    DateTime? shiftEnd,
    String? adminTimezone,
    String? teacherTimezone,
    IslamicSubject? subject,
    String? subjectId,
    String? subjectDisplayName,
    String? autoGeneratedName,
    String? customName,
    double? hourlyRate,
    ShiftStatus? status,
    String? createdByAdminId,
    DateTime? createdAt,
    DateTime? lastModified,
    RecurrencePattern? recurrence,
    EnhancedRecurrence? enhancedRecurrence,
    DateTime? recurrenceEndDate,
    Map<String, dynamic>? recurrenceSettings,
    String? notes,
    DateTime? clockInTime,
    DateTime? clockOutTime,
    bool? isManualOverride,
    String? lastClockInPlatform,
    DateTime? activatedAt,
    bool? autoClockOut,
    String? autoClockOutReason,
    String? completionState,
    int? workedMinutes,
    bool? isPublished,
    String? publishedBy,
    DateTime? publishedAt,
    String? originalTeacherId,
    String? originalTeacherName,
    ShiftCategory? category,
    String? leaderRole,
    String? zoomMeetingId,
    String? zoomEncryptedJoinUrl,
    DateTime? zoomMeetingCreatedAt,
    DateTime? zoomInviteSentAt,
    String? hubMeetingId,
    String? breakoutRoomName,
    String? breakoutRoomKey,
    String? zoomRoutingMode,
    List<Map<String, dynamic>>? routingRiskParticipants,
    List<String>? preAssignedParticipants,
    bool? hasRoutingRisk,
  }) {
    return TeachingShift(
      id: id ?? this.id,
      teacherId: teacherId ?? this.teacherId,
      teacherName: teacherName ?? this.teacherName,
      studentIds: studentIds ?? this.studentIds,
      studentNames: studentNames ?? this.studentNames,
      shiftStart: shiftStart ?? this.shiftStart,
      shiftEnd: shiftEnd ?? this.shiftEnd,
      adminTimezone: adminTimezone ?? this.adminTimezone,
      teacherTimezone: teacherTimezone ?? this.teacherTimezone,
      subject: subject ?? this.subject,
      subjectId: subjectId ?? this.subjectId,
      subjectDisplayName: subjectDisplayName ?? this.subjectDisplayName,
      autoGeneratedName: autoGeneratedName ?? this.autoGeneratedName,
      customName: customName ?? this.customName,
      hourlyRate: hourlyRate ?? this.hourlyRate,
      status: status ?? this.status,
      createdByAdminId: createdByAdminId ?? this.createdByAdminId,
      createdAt: createdAt ?? this.createdAt,
      lastModified: lastModified ?? DateTime.now(),
      recurrence: recurrence ?? this.recurrence,
      enhancedRecurrence: enhancedRecurrence ?? this.enhancedRecurrence,
      recurrenceEndDate: recurrenceEndDate ?? this.recurrenceEndDate,
      recurrenceSettings: recurrenceSettings ?? this.recurrenceSettings,
      notes: notes ?? this.notes,
      clockInTime: clockInTime ?? this.clockInTime,
      clockOutTime: clockOutTime ?? this.clockOutTime,
      isManualOverride: isManualOverride ?? this.isManualOverride,
      lastClockInPlatform: lastClockInPlatform ?? this.lastClockInPlatform,
      activatedAt: activatedAt ?? this.activatedAt,
      autoClockOut: autoClockOut ?? this.autoClockOut,
      autoClockOutReason: autoClockOutReason ?? this.autoClockOutReason,
      completionState: completionState ?? this.completionState,
      workedMinutes: workedMinutes ?? this.workedMinutes,
      isPublished: isPublished ?? this.isPublished,
      publishedBy: publishedBy ?? this.publishedBy,
      publishedAt: publishedAt ?? this.publishedAt,
      originalTeacherId: originalTeacherId ?? this.originalTeacherId,
      originalTeacherName: originalTeacherName ?? this.originalTeacherName,
      category: category ?? this.category,
      leaderRole: leaderRole ?? this.leaderRole,
      zoomMeetingId: zoomMeetingId ?? this.zoomMeetingId,
      zoomEncryptedJoinUrl: zoomEncryptedJoinUrl ?? this.zoomEncryptedJoinUrl,
      zoomMeetingCreatedAt: zoomMeetingCreatedAt ?? this.zoomMeetingCreatedAt,
      zoomInviteSentAt: zoomInviteSentAt ?? this.zoomInviteSentAt,
      hubMeetingId: hubMeetingId ?? this.hubMeetingId,
      breakoutRoomName: breakoutRoomName ?? this.breakoutRoomName,
      breakoutRoomKey: breakoutRoomKey ?? this.breakoutRoomKey,
      zoomRoutingMode: zoomRoutingMode ?? this.zoomRoutingMode,
      routingRiskParticipants:
          routingRiskParticipants ?? this.routingRiskParticipants,
      preAssignedParticipants:
          preAssignedParticipants ?? this.preAssignedParticipants,
      hasRoutingRisk: hasRoutingRisk ?? this.hasRoutingRisk,
    );
  }
}
