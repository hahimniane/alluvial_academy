import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'enhanced_recurrence.dart';
import '../enums/shift_enums.dart';

class TeachingShift {
  // No grace period - shifts are marked as missed immediately after end time
  // static const Duration clockInGracePeriod = Duration(minutes: 15); // REMOVED - handled by backend

  final String id;
  final String teacherId;
  final String teacherName;
  final List<String> studentIds;
  final List<String> studentNames;
  final DateTime shiftStart;
  final DateTime shiftEnd;
  final String adminTimezone;
  final String teacherTimezone;
  final IslamicSubject subject; // Legacy field for backward compatibility
  final String? subjectId; // New field for dynamic subjects
  final String?
      subjectDisplayName; // Cache subject display name for performance
  final String autoGeneratedName;
  final String? customName;
  final double hourlyRate;
  final ShiftStatus status;
  final String createdByAdminId;
  final DateTime createdAt;
  final DateTime? lastModified;
  final RecurrencePattern recurrence; // Keep for backward compatibility
  final DateTime? recurrenceEndDate;
  final Map<String, dynamic>? recurrenceSettings;
  final String? recurrenceSeriesId; // Links shifts in same recurring series
  final DateTime? seriesCreatedAt; // Timestamp when series was first created
  final EnhancedRecurrence enhancedRecurrence; // New enhanced recurrence
  final String? templateId; // Shift template ID for dev rolling schedules
  final bool generatedFromTemplate; // True if materialized from a template
  final String? notes;

  // Clock-in/out tracking fields
  final DateTime? clockInTime;
  final DateTime? clockOutTime;
  final bool isManualOverride; // For admin manual adjustments
  final String?
      lastClockInPlatform; // Platform used for last clock-in (web, android, ios)
  final DateTime? activatedAt; // When the shift window officially opened
  final bool autoClockOut; // Whether the system performed clock-out
  final String? autoClockOutReason; // Reason for system clock-out
  final String?
      completionState; // human-readable completion summary (e.g. partial/full)
  final int? workedMinutes; // Total minutes worked across timesheets

  // Shift publishing fields (for teacher shift sharing)
  final bool isPublished; // Whether the shift is published for other teachers
  final String? publishedBy; // User ID of the teacher who published it
  final DateTime? publishedAt; // When the shift was published
  final String?
      originalTeacherId; // Original teacher ID (preserved when claimed)
  final String?
      originalTeacherName; // Original teacher name (preserved when claimed)

  // Shift category and leader role fields
  final ShiftCategory
      category; // Distinguishes teaching vs leadership schedules
  final String?
      leaderRole; // Role for leader shifts (admin, coordination, meeting, etc.)

  // Legacy Zoom meeting fields - kept for backward compatibility during migration
  @Deprecated('Zoom support has been removed. All shifts use LiveKit.')
  final String? zoomMeetingId;
  @Deprecated('Zoom support has been removed. All shifts use LiveKit.')
  final String? zoomEncryptedJoinUrl;
  @Deprecated('Zoom support has been removed. All shifts use LiveKit.')
  final DateTime? zoomMeetingCreatedAt;
  @Deprecated('Zoom support has been removed. All shifts use LiveKit.')
  final DateTime? zoomInviteSentAt;

  // Hub Meeting Fields
  final String? hubMeetingId;
  final String? breakoutRoomName;
  final String? breakoutRoomKey;
  final String? zoomRoutingMode; // "preassign", "selfselect", "hybrid"

  // Routing Risk Fields (for Zoom breakout pre-assignment)
  final List<Map<String, dynamic>> routingRiskParticipants;
  final List<String> preAssignedParticipants;
  final bool hasRoutingRisk;

  // Video Provider Fields - all shifts now use LiveKit
  @Deprecated('All shifts use LiveKit. This field is kept for backward compatibility.')
  final VideoProvider videoProvider; // Now always defaults to livekit
  final String? livekitRoomName; // e.g., "shift_<shiftId>"
  final DateTime? livekitLastTokenIssuedAt;

  // PERFORMANCE OPTIMIZATION: Pre-calculated UI fields (calculated once during parsing)
  // These avoid recalculating on every build() call (60fps)
  late final String uiStudentNames; // Formatted student names for display
  late final String uiStudentNamesAbbreviated; // First name + last initial (for monthly view)
  late final Color uiStatusColor; // Status color for calendar cards

  TeachingShift({
    required this.id,
    required this.teacherId,
    required this.teacherName,
    required this.studentIds,
    required this.studentNames,
    required this.shiftStart,
    required this.shiftEnd,
    required this.adminTimezone,
    required this.teacherTimezone,
    required this.subject,
    this.subjectId,
    this.subjectDisplayName,
    required this.autoGeneratedName,
    this.customName,
    required this.hourlyRate,
    required this.status,
    required this.createdByAdminId,
    required this.createdAt,
    this.lastModified,
    this.recurrence = RecurrencePattern.none,
    this.recurrenceEndDate,
    this.recurrenceSettings,
    this.recurrenceSeriesId,
    this.seriesCreatedAt,
    this.enhancedRecurrence = const EnhancedRecurrence(),
    this.templateId,
    this.generatedFromTemplate = false,
    this.notes,
    this.clockInTime,
    this.clockOutTime,
    this.isManualOverride = false,
    this.lastClockInPlatform,
    this.activatedAt,
    this.autoClockOut = false,
    this.autoClockOutReason,
    this.completionState,
    this.workedMinutes,
    this.isPublished = false,
    this.publishedBy,
    this.publishedAt,
    this.originalTeacherId,
    this.originalTeacherName,
    this.category = ShiftCategory.teaching,
    this.leaderRole,
    this.zoomMeetingId,
    this.zoomEncryptedJoinUrl,
    this.zoomMeetingCreatedAt,
    this.zoomInviteSentAt,
    this.hubMeetingId,
    this.breakoutRoomName,
    this.breakoutRoomKey,
    this.zoomRoutingMode,
    this.routingRiskParticipants = const [],
    this.preAssignedParticipants = const [],
    this.hasRoutingRisk = false,
    this.videoProvider = VideoProvider.livekit,
    this.livekitRoomName,
    this.livekitLastTokenIssuedAt,
  }) {
    // PERFORMANCE OPTIMIZATION: Pre-calculate UI strings once during construction
    // This avoids recalculating on every build() call (60fps)
    uiStudentNames = _generateStudentNamesString(studentNames);
    uiStudentNamesAbbreviated = _generateAbbreviatedNamesString(studentNames);
    uiStatusColor = _generateStatusColor(status, clockInTime, shiftStart, shiftEnd);
  }
  
  /// Generate formatted student names string (calculated once)
  String _generateStudentNamesString(List<String> names) {
    if (names.isEmpty) return 'No students';
    if (names.length == 1) return names[0];
    if (names.length <= 3) return names.join(', ');
    return '${names.take(2).join(', ')} +${names.length - 2}';
  }
  
  /// Generate abbreviated names (first name + last initial) for monthly view
  String _generateAbbreviatedNamesString(List<String> names) {
    if (names.isEmpty) return 'No students';
    
    final abbreviated = names.map((fullName) {
      final parts = fullName.trim().split(' ');
      if (parts.isEmpty) return fullName;
      if (parts.length == 1) return parts[0]; // Only one name, return as is
      // First name + last initial
      final firstName = parts[0];
      final lastInitial = parts.last[0].toUpperCase();
      return '$firstName $lastInitial.';
    }).toList();
    
    if (abbreviated.length == 1) return abbreviated[0];
    if (abbreviated.length <= 3) return abbreviated.join(', ');
    return '${abbreviated.take(2).join(', ')} +${abbreviated.length - 2}';
  }
  
  /// Generate status color (calculated once)
  /// Note: This is calculated at construction time, so it's static based on initial state
  /// For real-time updates (e.g., clock-in during shift), the UI should check isClockedIn property
  Color _generateStatusColor(ShiftStatus status, DateTime? clockInTime, DateTime shiftStart, DateTime shiftEnd) {
    // Standard status colors (calculated once at construction)
    // Real-time status (like active clock-in) should be checked via isClockedIn property
    switch (status) {
      case ShiftStatus.scheduled:
        return const Color(0xffF59E0B); // amber
      case ShiftStatus.active:
        return const Color(0xff10B981); // green
      case ShiftStatus.partiallyCompleted:
        return const Color(0xffF97316); // orange
      case ShiftStatus.fullyCompleted:
        return const Color(0xff6366F1); // indigo
      case ShiftStatus.completed:
        return const Color(0xff6366F1); // indigo
      case ShiftStatus.missed:
        return const Color(0xffEF4444); // red
      case ShiftStatus.cancelled:
        return const Color(0xff9CA3AF); // gray
    }
  }

  // Legacy - Zoom support removed. Kept for backward compatibility.
  @Deprecated('Zoom support has been removed. All shifts use LiveKit.')
  bool get hasZoomMeeting =>
      (zoomMeetingId != null && zoomMeetingId!.isNotEmpty) ||
      (hubMeetingId != null && hubMeetingId!.isNotEmpty);

  // Check if shift uses LiveKit as video provider (always true now)
  bool get usesLiveKit => true;

  // Legacy - Zoom support removed
  @Deprecated('Zoom support has been removed. All shifts use LiveKit.')
  bool get usesZoom => false;

  // Check if video call is available - always true with LiveKit (rooms are created on-demand)
  bool get hasVideoCall => true;

  // Get the effective room name for LiveKit (generates default if not set)
  String get effectiveLivekitRoomName =>
      livekitRoomName ?? 'shift_$id';

  // Get the display name (custom name takes priority over auto-generated)
  String get displayName => customName ?? autoGeneratedName;

  // Get shift duration in hours
  double get shiftDurationHours {
    return shiftEnd.difference(shiftStart).inMinutes / 60.0;
  }

  int get scheduledDurationMinutes {
    return shiftEnd.difference(shiftStart).inMinutes;
  }

  bool get hasWorked => (workedMinutes ?? 0) > 0;

  bool get hasWorkedFull =>
      workedMinutes != null && workedMinutes! >= scheduledDurationMinutes;

  bool get hasWorkedPartially =>
      workedMinutes != null &&
      workedMinutes! > 0 &&
      workedMinutes! < scheduledDurationMinutes;

  double? get workedRatio {
    if (workedMinutes == null) return null;
    final sched = scheduledDurationMinutes;
    if (sched <= 0) return null;
    return workedMinutes! / sched;
  }

  ShiftStatus deriveCompletionStatus({int toleranceMinutes = 1}) {
    if (!hasWorked) {
      return ShiftStatus.missed;
    }
    final sched = scheduledDurationMinutes;
    if (workedMinutes != null && workedMinutes! + toleranceMinutes >= sched) {
      return ShiftStatus.fullyCompleted;
    }
    return ShiftStatus.partiallyCompleted;
  }

  // Calculate total payment for this shift
  double get totalPayment {
    return shiftDurationHours * hourlyRate;
  }

  // Get subject display name - use cached value if available, otherwise fallback to enum
  String get effectiveSubjectDisplayName {
    // Use the cached display name if available (for dynamic subjects)
    if (subjectDisplayName != null && subjectDisplayName!.isNotEmpty) {
      return subjectDisplayName!;
    }

    // Otherwise, fallback to enum-based display name
    switch (subject) {
      case IslamicSubject.quranStudies:
        return 'Quran Studies';
      case IslamicSubject.hadithStudies:
        return 'Hadith Studies';
      case IslamicSubject.fiqh:
        return 'Islamic Jurisprudence (Fiqh)';
      case IslamicSubject.arabicLanguage:
        return 'Arabic Language';
      case IslamicSubject.islamicHistory:
        return 'Islamic History';
      case IslamicSubject.aqeedah:
        return 'Islamic Creed (Aqeedah)';
      case IslamicSubject.tafseer:
        return 'Quran Interpretation (Tafseer)';
      case IslamicSubject.seerah:
        return 'Prophet\'s Biography (Seerah)';
      case IslamicSubject.other:
        // For non-Islamic subjects, the display name should come from subjectDisplayName
        // If we reach here, it means subjectDisplayName was not set
        return 'Other Subject';
    }
  }

  // Check if teacher can clock in (1 minute before shift start until shift end)
  bool get canClockIn {
    final nowUtc = DateTime.now().toUtc();
    final shiftStartUtc = shiftStart.toUtc();
    final shiftEndUtc = shiftEnd.toUtc();
    
    // Allow clock-in 1 minute before shift start
    final clockInWindowStartUtc = shiftStartUtc.subtract(const Duration(minutes: 1));

    final isOnOrAfterWindowStart = !nowUtc.isBefore(clockInWindowStartUtc);
    final isOnOrBeforeEnd = !nowUtc.isAfter(shiftEndUtc);

    return isOnOrAfterWindowStart && isOnOrBeforeEnd;
  }

  // Check if shift is currently active
  bool get isCurrentlyActive {
    final nowUtc = DateTime.now().toUtc();
    // Compare in UTC to ensure timezone consistency
    final shiftStartUtc = shiftStart.toUtc();
    final shiftEndUtc = shiftEnd.toUtc();
    return nowUtc.isAfter(shiftStartUtc) && nowUtc.isBefore(shiftEndUtc);
  }

  // Check if shift has expired (immediately after end time, no grace period)
  bool get hasExpired {
    final nowUtc = DateTime.now().toUtc();
    // Compare in UTC to ensure timezone consistency
    final shiftEndUtc = shiftEnd.toUtc();
    // No grace period - expires immediately when shift ends
    return nowUtc.isAfter(shiftEndUtc);
  }

  // Check if teacher is currently clocked in
  bool get isClockedIn {
    return clockInTime != null &&
        clockOutTime == null &&
        status == ShiftStatus.active;
  }

  // Check if teacher can clock out
  bool get canClockOut {
    return isClockedIn && !hasExpired;
  }

  // Check if shift needs auto-logout (clocked in but expired)
  bool get needsAutoLogout {
    return isClockedIn && hasExpired;
  }

  // Clock-in deadline is the shift end time (no grace period)
  // Backend monitoring handles missed shift detection
  @Deprecated('Grace period removed - use shift end time directly')
  DateTime clockInGraceDeadline({DateTime? nextShiftStartUtc}) {
    // Grace period has been removed to simplify logic
    // Shifts are marked as missed immediately after end time
    return shiftEnd.toUtc();
  }

  // Check if shift should be marked as missed
  // Shift is missed if it has ended and teacher never clocked in
  // This is now handled by backend cloud function to avoid timezone issues
  @Deprecated('Use backend monitoring instead')
  bool shouldBeMarkedAsMissed({
    DateTime? nowUtcOverride,
    DateTime? nextShiftStartUtc,
  }) {
    // This method is deprecated - shift status monitoring is now handled
    // by the backend cloud function (monitorShiftStatuses) to ensure
    // consistent UTC-based checking and avoid timezone issues
    return false;
  }

  // Get actual shift duration based on clock-in/out times
  Duration? get actualShiftDuration {
    if (clockInTime != null && clockOutTime != null) {
      return clockOutTime!.difference(clockInTime!);
    }
    return null;
  }

  // Get actual shift duration in hours for payment calculation
  double? get actualShiftDurationHours {
    final duration = actualShiftDuration;
    return duration != null ? duration.inMinutes / 60.0 : null;
  }

  // Calculate payment based on actual worked hours (if clocked out) or scheduled hours
  double get actualPayment {
    final actualHours = actualShiftDurationHours;
    return actualHours != null ? actualHours * hourlyRate : totalPayment;
  }

  // Get clock-in window start time (exact shift start, no grace)
  DateTime get clockInWindowStart {
    // Use UTC for consistency
    return shiftStart.toUtc();
  }

  // Get clock-out deadline (exact shift end, no grace period)
  DateTime get clockOutDeadline {
    // Use UTC for consistency
    return shiftEnd.toUtc();
  }

  // Generate automatic name based on teacher, subject, and students
  static String generateAutoName({
    required String teacherName,
    required IslamicSubject subject,
    required List<String> studentNames,
  }) {
    String subjectName = _getSubjectShortName(subject);

    if (studentNames.isEmpty) {
      return '$teacherName - $subjectName';
    } else if (studentNames.length == 1) {
      return '$teacherName - $subjectName - ${studentNames[0]}';
    } else if (studentNames.length <= 3) {
      return '$teacherName - $subjectName - ${studentNames.join(', ')}';
    } else {
      return '$teacherName - $subjectName - ${studentNames.take(2).join(', ')} +${studentNames.length - 2} more';
    }
  }

  static String _getSubjectShortName(IslamicSubject subject) {
    switch (subject) {
      case IslamicSubject.quranStudies:
        return 'Quran';
      case IslamicSubject.hadithStudies:
        return 'Hadith';
      case IslamicSubject.fiqh:
        return 'Fiqh';
      case IslamicSubject.arabicLanguage:
        return 'Arabic';
      case IslamicSubject.islamicHistory:
        return 'History';
      case IslamicSubject.aqeedah:
        return 'Aqeedah';
      case IslamicSubject.tafseer:
        return 'Tafseer';
      case IslamicSubject.seerah:
        return 'Seerah';
      case IslamicSubject.other:
        return 'Other';
    }
  }

  // Convert to Firestore document
  Map<String, dynamic> toFirestore() {
    return {
      'id': id,
      'teacher_id': teacherId,
      'teacher_name': teacherName,
      'student_ids': studentIds,
      'student_names': studentNames,
      'shift_start': Timestamp.fromDate(shiftStart),
      'shift_end': Timestamp.fromDate(shiftEnd),
      'admin_timezone': adminTimezone,
      'teacher_timezone': teacherTimezone,
      'subject': subject.name,
      'subject_id': subjectId,
      'subject_display_name': subjectDisplayName,
      'auto_generated_name': autoGeneratedName,
      'custom_name': customName,
      'hourly_rate': hourlyRate,
      'status': status.name,
      'created_by_admin_id': createdByAdminId,
      'created_at': Timestamp.fromDate(createdAt),
      'last_modified':
          lastModified != null ? Timestamp.fromDate(lastModified!) : null,
      'recurrence': recurrence.name,
      'enhanced_recurrence': enhancedRecurrence.toFirestore(),
      'recurrence_end_date': recurrenceEndDate != null
          ? Timestamp.fromDate(recurrenceEndDate!)
          : null,
      'recurrence_settings': recurrenceSettings,
      'recurrence_series_id': recurrenceSeriesId,
      'series_created_at':
          seriesCreatedAt != null ? Timestamp.fromDate(seriesCreatedAt!) : null,
      if (templateId != null) 'template_id': templateId,
      if (generatedFromTemplate) 'generated_from_template': true,
      'notes': notes,
      'clock_in_time':
          clockInTime != null ? Timestamp.fromDate(clockInTime!) : null,
      'clock_out_time':
          clockOutTime != null ? Timestamp.fromDate(clockOutTime!) : null,
      'is_manual_override': isManualOverride,
      'last_clock_in_platform': lastClockInPlatform,
      'activated_at':
          activatedAt != null ? Timestamp.fromDate(activatedAt!) : null,
      'auto_clock_out': autoClockOut,
      'auto_clock_out_reason': autoClockOutReason,
      'completion_state': completionState,
      'worked_minutes': workedMinutes,
      'is_published': isPublished,
      'published_by': publishedBy,
      'published_at':
          publishedAt != null ? Timestamp.fromDate(publishedAt!) : null,
      'original_teacher_id': originalTeacherId,
      'original_teacher_name': originalTeacherName,
      'shift_category': category.name,
      'leader_role': leaderRole,
      'zoom_meeting_id': zoomMeetingId,
      'zoom_encrypted_join_url': zoomEncryptedJoinUrl,
      'zoom_meeting_created_at': zoomMeetingCreatedAt != null
          ? Timestamp.fromDate(zoomMeetingCreatedAt!)
          : null,
      'zoom_invite_sent_at': zoomInviteSentAt != null
          ? Timestamp.fromDate(zoomInviteSentAt!)
          : null,
      'hubMeetingId': hubMeetingId,
      'breakoutRoomName': breakoutRoomName,
      'breakoutRoomKey': breakoutRoomKey,
      'zoomRoutingMode': zoomRoutingMode,
      'routingRiskParticipants': routingRiskParticipants,
      'preAssignedParticipants': preAssignedParticipants,
      'hasRoutingRisk': hasRoutingRisk,
      'video_provider': videoProvider.name,
      'livekit_room_name': livekitRoomName,
      'livekit_last_token_issued_at': livekitLastTokenIssuedAt != null
          ? Timestamp.fromDate(livekitLastTokenIssuedAt!)
          : null,
    };
  }

  // Create from Firestore document
  factory TeachingShift.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;

    ShiftCategory parseCategory() {
      final raw = data['shift_category'] ?? data['shiftCategory'] ?? 'teaching';
      return ShiftCategory.values.firstWhere(
        (e) => e.name == raw,
        orElse: () => ShiftCategory.teaching,
      );
    }

    final category = parseCategory();

    String? parseString(dynamic value) {
      if (value == null) return null;
      if (value is String) return value;
      return value.toString();
    }

    final zoomMeetingId = parseString(data['zoom_meeting_id'] ?? data['zoomMeetingId']);
    final zoomEncryptedJoinUrl =
        parseString(data['zoom_encrypted_join_url'] ?? data['zoomEncryptedJoinUrl']);
    final hubMeetingId =
        parseString(data['hubMeetingId'] ?? data['hub_meeting_id'] ?? data['hubMeetingID']);

    final breakoutRoomName =
        parseString(data['breakoutRoomName'] ?? data['breakout_room_name']);
    final breakoutRoomKey =
        parseString(data['breakoutRoomKey'] ?? data['breakout_room_key']);
    final zoomRoutingMode =
        parseString(data['zoomRoutingMode'] ?? data['zoom_routing_mode']);

    VideoProvider parseVideoProvider() {
      // All shifts now use LiveKit - Zoom support has been removed
      // We still parse the field for backward compatibility during migration
      final rawProvider = parseString(data['video_provider'] ?? data['videoProvider']);
      if (rawProvider != null && rawProvider.trim().isNotEmpty) {
        final normalized = rawProvider.trim().toLowerCase();
        // Only return zoom if explicitly set (for any remaining legacy data)
        if (normalized == 'zoom') {
          // Even if it says zoom, treat as livekit since zoom is deprecated
          return VideoProvider.livekit;
        }
      }
      // Default to LiveKit for all shifts
      return VideoProvider.livekit;
    }

    final videoProvider = parseVideoProvider();

    return TeachingShift(
      id: data['id'] ?? doc.id,
      teacherId: data['teacher_id'] ?? '',
      teacherName: data['teacher_name'] ?? '',
      studentIds: List<String>.from(data['student_ids'] ?? []),
      studentNames: List<String>.from(data['student_names'] ?? []),
      shiftStart: (data['shift_start'] as Timestamp).toDate(),
      shiftEnd: (data['shift_end'] as Timestamp).toDate(),
      adminTimezone: data['admin_timezone'] ?? 'UTC',
      teacherTimezone: data['teacher_timezone'] ?? 'UTC',
      subject: IslamicSubject.values.firstWhere(
        (e) => e.name == data['subject'],
        orElse: () => IslamicSubject.quranStudies,
      ),
      subjectId: data['subject_id'],
      subjectDisplayName: data['subject_display_name'],
      autoGeneratedName: data['auto_generated_name'] ?? '',
      customName: data['custom_name'],
      hourlyRate: (data['hourly_rate'] ?? 0.0).toDouble(),
      status: ShiftStatus.values.firstWhere(
        (e) => e.name == data['status'],
        orElse: () => ShiftStatus.scheduled,
      ),
      createdByAdminId: data['created_by_admin_id'] ?? '',
      createdAt: (data['created_at'] as Timestamp).toDate(),
      lastModified: data['last_modified'] != null
          ? (data['last_modified'] as Timestamp).toDate()
          : null,
      recurrence: RecurrencePattern.values.firstWhere(
        (e) => e.name == data['recurrence'],
        orElse: () => RecurrencePattern.none,
      ),
      recurrenceSeriesId: data['recurrence_series_id'],
      seriesCreatedAt: data['series_created_at'] != null
          ? (data['series_created_at'] as Timestamp).toDate()
          : null,
      enhancedRecurrence: data['enhanced_recurrence'] != null
          ? EnhancedRecurrence.fromFirestore(
              Map<String, dynamic>.from(data['enhanced_recurrence']))
          : const EnhancedRecurrence(),
      recurrenceEndDate: data['recurrence_end_date'] != null
          ? (data['recurrence_end_date'] as Timestamp).toDate()
          : null,
      recurrenceSettings: data['recurrence_settings'],
      templateId: data['template_id'],
      generatedFromTemplate: data['generated_from_template'] == true,
      notes: data['notes'],
      clockInTime: data['clock_in_time'] != null
          ? (data['clock_in_time'] as Timestamp).toDate()
          : null,
      clockOutTime: data['clock_out_time'] != null
          ? (data['clock_out_time'] as Timestamp).toDate()
          : null,
      isManualOverride: data['is_manual_override'] ?? false,
      lastClockInPlatform: data['last_clock_in_platform'],
      activatedAt: data['activated_at'] != null
          ? (data['activated_at'] as Timestamp).toDate()
          : null,
      autoClockOut: data['auto_clock_out'] ?? false,
      autoClockOutReason: data['auto_clock_out_reason'],
      completionState: data['completion_state'],
      workedMinutes: data['worked_minutes'],
      isPublished: data['is_published'] ?? false,
      publishedBy: data['published_by'],
      publishedAt: data['published_at'] != null
          ? (data['published_at'] as Timestamp).toDate()
          : null,
      originalTeacherId: data['original_teacher_id'],
      originalTeacherName: data['original_teacher_name'],
      category: category,
      leaderRole: data['leader_role'],
      zoomMeetingId: zoomMeetingId,
      zoomEncryptedJoinUrl: zoomEncryptedJoinUrl,
      zoomMeetingCreatedAt: data['zoom_meeting_created_at'] != null
          ? (data['zoom_meeting_created_at'] as Timestamp).toDate()
          : null,
      zoomInviteSentAt: data['zoom_invite_sent_at'] != null
          ? (data['zoom_invite_sent_at'] as Timestamp).toDate()
          : null,
      hubMeetingId: hubMeetingId,
      breakoutRoomName: breakoutRoomName,
      breakoutRoomKey: breakoutRoomKey,
      zoomRoutingMode: zoomRoutingMode,
      routingRiskParticipants: data['routingRiskParticipants'] != null
          ? List<Map<String, dynamic>>.from(
              (data['routingRiskParticipants'] as List)
                  .map((e) => Map<String, dynamic>.from(e as Map)))
          : const [],
      preAssignedParticipants: data['preAssignedParticipants'] != null
          ? List<String>.from(data['preAssignedParticipants'])
          : const [],
      hasRoutingRisk: data['hasRoutingRisk'] ?? false,
      videoProvider: videoProvider,
      livekitRoomName: data['livekit_room_name'],
      livekitLastTokenIssuedAt: data['livekit_last_token_issued_at'] != null
          ? (data['livekit_last_token_issued_at'] as Timestamp).toDate()
          : null,
    ).._initializeUICache(); // Initialize pre-calculated UI fields
  }
  
  /// Initialize pre-calculated UI cache after construction
  void _initializeUICache() {
    // These are already set in constructor, but ensure they're initialized
    // This method is called after fromFirestore to ensure cache is set
  }

  // Create a copy with updated fields
  TeachingShift copyWith({
    String? id,
    String? teacherId,
    String? teacherName,
    List<String>? studentIds,
    List<String>? studentNames,
    DateTime? shiftStart,
    DateTime? shiftEnd,
    String? adminTimezone,
    String? teacherTimezone,
    IslamicSubject? subject,
    String? subjectId,
    String? subjectDisplayName,
    String? autoGeneratedName,
    String? customName,
    double? hourlyRate,
    ShiftStatus? status,
    String? createdByAdminId,
    DateTime? createdAt,
    DateTime? lastModified,
    RecurrencePattern? recurrence,
    EnhancedRecurrence? enhancedRecurrence,
    DateTime? recurrenceEndDate,
    Map<String, dynamic>? recurrenceSettings,
    String? recurrenceSeriesId,
    DateTime? seriesCreatedAt,
    String? templateId,
    bool? generatedFromTemplate,
    String? notes,
    DateTime? clockInTime,
    DateTime? clockOutTime,
    bool? isManualOverride,
    String? lastClockInPlatform,
    DateTime? activatedAt,
    bool? autoClockOut,
    String? autoClockOutReason,
    String? completionState,
    int? workedMinutes,
    bool? isPublished,
    String? publishedBy,
    DateTime? publishedAt,
    String? originalTeacherId,
    String? originalTeacherName,
    ShiftCategory? category,
    String? leaderRole,
    String? zoomMeetingId,
    String? zoomEncryptedJoinUrl,
    DateTime? zoomMeetingCreatedAt,
    DateTime? zoomInviteSentAt,
    String? hubMeetingId,
    String? breakoutRoomName,
    String? breakoutRoomKey,
    String? zoomRoutingMode,
    List<Map<String, dynamic>>? routingRiskParticipants,
    List<String>? preAssignedParticipants,
    bool? hasRoutingRisk,
    VideoProvider? videoProvider,
    String? livekitRoomName,
    DateTime? livekitLastTokenIssuedAt,
  }) {
    return TeachingShift(
      id: id ?? this.id,
      teacherId: teacherId ?? this.teacherId,
      teacherName: teacherName ?? this.teacherName,
      studentIds: studentIds ?? this.studentIds,
      studentNames: studentNames ?? this.studentNames,
      shiftStart: shiftStart ?? this.shiftStart,
      shiftEnd: shiftEnd ?? this.shiftEnd,
      adminTimezone: adminTimezone ?? this.adminTimezone,
      teacherTimezone: teacherTimezone ?? this.teacherTimezone,
      subject: subject ?? this.subject,
      subjectId: subjectId ?? this.subjectId,
      subjectDisplayName: subjectDisplayName ?? this.subjectDisplayName,
      autoGeneratedName: autoGeneratedName ?? this.autoGeneratedName,
      customName: customName ?? this.customName,
      hourlyRate: hourlyRate ?? this.hourlyRate,
      status: status ?? this.status,
      createdByAdminId: createdByAdminId ?? this.createdByAdminId,
      createdAt: createdAt ?? this.createdAt,
      lastModified: lastModified ?? DateTime.now(),
      recurrence: recurrence ?? this.recurrence,
      enhancedRecurrence: enhancedRecurrence ?? this.enhancedRecurrence,
      recurrenceEndDate: recurrenceEndDate ?? this.recurrenceEndDate,
      recurrenceSettings: recurrenceSettings ?? this.recurrenceSettings,
      recurrenceSeriesId: recurrenceSeriesId ?? this.recurrenceSeriesId,
      seriesCreatedAt: seriesCreatedAt ?? this.seriesCreatedAt,
      templateId: templateId ?? this.templateId,
      generatedFromTemplate:
          generatedFromTemplate ?? this.generatedFromTemplate,
      notes: notes ?? this.notes,
      clockInTime: clockInTime ?? this.clockInTime,
      clockOutTime: clockOutTime ?? this.clockOutTime,
      isManualOverride: isManualOverride ?? this.isManualOverride,
      lastClockInPlatform: lastClockInPlatform ?? this.lastClockInPlatform,
      activatedAt: activatedAt ?? this.activatedAt,
      autoClockOut: autoClockOut ?? this.autoClockOut,
      autoClockOutReason: autoClockOutReason ?? this.autoClockOutReason,
      completionState: completionState ?? this.completionState,
      workedMinutes: workedMinutes ?? this.workedMinutes,
      isPublished: isPublished ?? this.isPublished,
      publishedBy: publishedBy ?? this.publishedBy,
      publishedAt: publishedAt ?? this.publishedAt,
      originalTeacherId: originalTeacherId ?? this.originalTeacherId,
      originalTeacherName: originalTeacherName ?? this.originalTeacherName,
      category: category ?? this.category,
      leaderRole: leaderRole ?? this.leaderRole,
      zoomMeetingId: zoomMeetingId ?? this.zoomMeetingId,
      zoomEncryptedJoinUrl: zoomEncryptedJoinUrl ?? this.zoomEncryptedJoinUrl,
      zoomMeetingCreatedAt: zoomMeetingCreatedAt ?? this.zoomMeetingCreatedAt,
      zoomInviteSentAt: zoomInviteSentAt ?? this.zoomInviteSentAt,
      hubMeetingId: hubMeetingId ?? this.hubMeetingId,
      breakoutRoomName: breakoutRoomName ?? this.breakoutRoomName,
      breakoutRoomKey: breakoutRoomKey ?? this.breakoutRoomKey,
      zoomRoutingMode: zoomRoutingMode ?? this.zoomRoutingMode,
      routingRiskParticipants:
          routingRiskParticipants ?? this.routingRiskParticipants,
      preAssignedParticipants:
          preAssignedParticipants ?? this.preAssignedParticipants,
      hasRoutingRisk: hasRoutingRisk ?? this.hasRoutingRisk,
      videoProvider: videoProvider ?? this.videoProvider,
      livekitRoomName: livekitRoomName ?? this.livekitRoomName,
      livekitLastTokenIssuedAt:
          livekitLastTokenIssuedAt ?? this.livekitLastTokenIssuedAt,
    );
  }
}
