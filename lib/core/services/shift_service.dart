import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/teaching_shift.dart';
import '../models/employee_model.dart';

class ShiftService {
  static FirebaseFirestore get _firestore => FirebaseFirestore.instance;
  static final FirebaseAuth _auth = FirebaseAuth.instance;

  // Collection reference
  static CollectionReference get _shiftsCollection =>
      _firestore.collection('teaching_shifts');

  /// Create a new teaching shift
  static Future<String> createShift({
    required String teacherId,
    required List<String> studentIds,
    required DateTime shiftStart,
    required DateTime shiftEnd,
    required String adminTimezone,
    required IslamicSubject subject,
    String? customName,
    String? notes,
    RecurrencePattern recurrence = RecurrencePattern.none,
    DateTime? recurrenceEndDate,
    Map<String, dynamic>? recurrenceSettings,
  }) async {
    try {
      final currentUser = _auth.currentUser;
      if (currentUser == null) throw Exception('User not authenticated');

      // Get teacher information
      final teacherDoc =
          await _firestore.collection('users').doc(teacherId).get();
      if (!teacherDoc.exists) throw Exception('Teacher not found');

      final teacherData = teacherDoc.data() as Map<String, dynamic>;
      final teacherName =
          '${teacherData['first_name']} ${teacherData['last_name']}';
      final teacherTimezone = teacherData['timezone'] ?? 'UTC';
      final hourlyRate = (teacherData['hourly_rate'] ?? 0.0).toDouble();

      // Get student information
      final studentNames = <String>[];
      for (String studentId in studentIds) {
        final studentDoc =
            await _firestore.collection('users').doc(studentId).get();
        if (studentDoc.exists) {
          final studentData = studentDoc.data() as Map<String, dynamic>;
          studentNames
              .add('${studentData['first_name']} ${studentData['last_name']}');
        }
      }

      // Generate auto name
      final autoGeneratedName = TeachingShift.generateAutoName(
        teacherName: teacherName,
        subject: subject,
        studentNames: studentNames,
      );

      // Create shift document
      final shiftDoc = _shiftsCollection.doc();
      final shift = TeachingShift(
        id: shiftDoc.id,
        teacherId: teacherId,
        teacherName: teacherName,
        studentIds: studentIds,
        studentNames: studentNames,
        shiftStart: shiftStart,
        shiftEnd: shiftEnd,
        adminTimezone: adminTimezone,
        teacherTimezone: teacherTimezone,
        subject: subject,
        autoGeneratedName: autoGeneratedName,
        customName: customName,
        hourlyRate: hourlyRate,
        status: ShiftStatus.scheduled,
        createdByAdminId: currentUser.uid,
        createdAt: DateTime.now(),
        recurrence: recurrence,
        recurrenceEndDate: recurrenceEndDate,
        recurrenceSettings: recurrenceSettings,
        notes: notes,
      );

      await shiftDoc.set(shift.toFirestore());

      // Create recurring shifts if specified
      if (recurrence != RecurrencePattern.none && recurrenceEndDate != null) {
        await _createRecurringShifts(shift, recurrenceEndDate);
      }

      print('Shift created successfully: ${shift.displayName}');
      return shiftDoc.id;
    } catch (e) {
      print('Error creating shift: $e');
      throw Exception('Failed to create shift: $e');
    }
  }

  /// Create recurring shifts based on pattern
  static Future<void> _createRecurringShifts(
    TeachingShift baseShift,
    DateTime endDate,
  ) async {
    try {
      final List<TeachingShift> recurringShifts = [];
      DateTime currentDate = baseShift.shiftStart;
      int maxRecurringShifts = 50; // Limit to prevent too many shifts
      int createdCount = 0;

      while (
          currentDate.isBefore(endDate) && createdCount < maxRecurringShifts) {
        DateTime nextDate;

        switch (baseShift.recurrence) {
          case RecurrencePattern.daily:
            nextDate = currentDate.add(const Duration(days: 1));
            break;
          case RecurrencePattern.weekly:
            nextDate = currentDate.add(const Duration(days: 7));
            break;
          case RecurrencePattern.monthly:
            nextDate = DateTime(
              currentDate.year,
              currentDate.month + 1,
              currentDate.day,
              currentDate.hour,
              currentDate.minute,
            );
            break;
          default:
            return;
        }

        if (nextDate.isAfter(endDate)) break;

        // Calculate shift end based on duration
        final shiftDuration =
            baseShift.shiftEnd.difference(baseShift.shiftStart);
        final nextShiftEnd = nextDate.add(shiftDuration);

        // Create recurring shift
        final recurringShift = baseShift.copyWith(
          id: _shiftsCollection.doc().id,
          shiftStart: nextDate,
          shiftEnd: nextShiftEnd,
          createdAt: DateTime.now(),
        );

        recurringShifts.add(recurringShift);
        currentDate = nextDate;
        createdCount++;
      }

      // Batch write all recurring shifts
      if (recurringShifts.isNotEmpty) {
        final batch = _firestore.batch();
        for (final shift in recurringShifts) {
          final docRef = _shiftsCollection.doc(shift.id);
          batch.set(docRef, shift.toFirestore());
        }
        await batch.commit();
        print('Created ${recurringShifts.length} recurring shifts');
      }
    } catch (e) {
      print('Error creating recurring shifts: $e');
    }
  }

  /// Get shifts for a specific teacher
  static Stream<List<TeachingShift>> getTeacherShifts(String teacherId) {
    return _shiftsCollection
        .where('teacher_id', isEqualTo: teacherId)
        .snapshots()
        .map((snapshot) {
      final shifts =
          snapshot.docs.map((doc) => TeachingShift.fromFirestore(doc)).toList();

      // Sort by shift_start since we can't use orderBy in query without index
      shifts.sort((a, b) => a.shiftStart.compareTo(b.shiftStart));

      return shifts;
    });
  }

  /// Get all shifts (admin view)
  static Stream<List<TeachingShift>> getAllShifts() {
    return _shiftsCollection.snapshots().map((snapshot) {
      final shifts =
          snapshot.docs.map((doc) => TeachingShift.fromFirestore(doc)).toList();

      // Sort by shift_start for consistent ordering
      shifts.sort((a, b) => a.shiftStart.compareTo(b.shiftStart));

      return shifts;
    });
  }

  /// Get shifts for today
  static Future<List<TeachingShift>> getTodayShifts(String teacherId) async {
    try {
      final today = DateTime.now();
      final startOfDay = DateTime(today.year, today.month, today.day);
      final endOfDay = startOfDay.add(const Duration(days: 1));

      final snapshot = await _shiftsCollection
          .where('teacher_id', isEqualTo: teacherId)
          .where('shift_start',
              isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay))
          .where('shift_start', isLessThan: Timestamp.fromDate(endOfDay))
          .get();

      return snapshot.docs
          .map((doc) => TeachingShift.fromFirestore(doc))
          .toList();
    } catch (e) {
      print('Error getting today\'s shifts: $e');
      return [];
    }
  }

  /// Get current active shift for teacher
  static Future<TeachingShift?> getCurrentActiveShift(String teacherId) async {
    try {
      final now = DateTime.now();
      final snapshot = await _shiftsCollection
          .where('teacher_id', isEqualTo: teacherId)
          .where('status', isEqualTo: 'active')
          .limit(1)
          .get();

      if (snapshot.docs.isEmpty) return null;

      final shift = TeachingShift.fromFirestore(snapshot.docs.first);

      // Verify shift is actually current
      if (shift.isCurrentlyActive || shift.canClockIn) {
        return shift;
      }

      return null;
    } catch (e) {
      print('Error getting current active shift: $e');
      return null;
    }
  }

  /// Update shift status
  static Future<void> updateShiftStatus(
      String shiftId, ShiftStatus status) async {
    try {
      await _shiftsCollection.doc(shiftId).update({
        'status': status.name,
        'last_modified': Timestamp.fromDate(DateTime.now()),
      });
      print('Shift status updated to: ${status.name}');
    } catch (e) {
      print('Error updating shift status: $e');
      throw Exception('Failed to update shift status');
    }
  }

  /// Delete a shift
  static Future<void> deleteShift(String shiftId) async {
    try {
      await _shiftsCollection.doc(shiftId).delete();
      print('Shift deleted successfully');
    } catch (e) {
      print('Error deleting shift: $e');
      throw Exception('Failed to delete shift');
    }
  }

  /// Delete multiple shifts at once
  static Future<void> deleteMultipleShifts(List<String> shiftIds) async {
    try {
      print('ShiftService: Deleting ${shiftIds.length} shifts');

      // Use a batch to delete all shifts atomically
      final batch = FirebaseFirestore.instance.batch();

      for (String shiftId in shiftIds) {
        batch.delete(_shiftsCollection.doc(shiftId));
      }

      await batch.commit();
      print('ShiftService: Successfully deleted ${shiftIds.length} shifts');
    } catch (e) {
      print('Error deleting multiple shifts: $e');
      throw Exception('Failed to delete multiple shifts');
    }
  }

  /// Update shift details
  static Future<void> updateShift(TeachingShift shift) async {
    try {
      await _shiftsCollection.doc(shift.id).update(shift.toFirestore());
      print('Shift updated successfully');
    } catch (e) {
      print('Error updating shift: $e');
      throw Exception('Failed to update shift');
    }
  }

  /// Clock in to a shift
  static Future<bool> clockIn(String teacherId, String shiftId) async {
    try {
      print(
          'ShiftService: Attempting clock-in for teacher $teacherId, shift $shiftId');

      final doc = await _shiftsCollection.doc(shiftId).get();
      if (!doc.exists) {
        print('ShiftService: ❌ Shift not found: $shiftId');
        return false;
      }

      print('ShiftService: ✅ Shift document found');
      final shift = TeachingShift.fromFirestore(doc);

      // Validation checks
      if (shift.teacherId != teacherId) {
        print(
            'ShiftService: ❌ Teacher ID mismatch: expected ${shift.teacherId}, got $teacherId');
        return false;
      }

      print('ShiftService: ✅ Teacher ID matches');

      // Allow clock-in if within time window (15 min before to 15 min after shift)
      print('ShiftService: Checking clock-in window...');
      print('ShiftService: shift.canClockIn = ${shift.canClockIn}');
      if (!shift.canClockIn) {
        print('ShiftService: ❌ Clock-in window not available');
        print('ShiftService: Current time: ${DateTime.now()}');
        print('ShiftService: Shift start: ${shift.shiftStart}');
        print('ShiftService: Shift end: ${shift.shiftEnd}');
        return false;
      }

      print('ShiftService: ✅ Clock-in window is available');

      // Allow multiple clock-ins within the same shift window
      // Remove status and isClockedIn checks to enable multiple entries

      // Check if teacher has any OTHER active shifts (not the current one)
      print('ShiftService: Checking for other active shifts...');
      final activeShiftsSnapshot = await _shiftsCollection
          .where('teacher_id', isEqualTo: teacherId)
          .where('status', isEqualTo: 'active')
          .get();

      // Convert to TeachingShift models so we can evaluate if they actually block a new clock-in.
      final otherActiveShifts = activeShiftsSnapshot.docs
          .where((doc) =>
              doc.id != shiftId) // exclude the shift we are clocking into
          .map((doc) => TeachingShift.fromFirestore(doc))
          // Ignore active shifts that have already surpassed their auto-logout deadline.
          // These shifts are "stuck" in active state because the auto-logout job hasn’t run yet
          // and shouldn’t prevent the teacher from starting a new session.
          .where((s) => !s.needsAutoLogout)
          .toList();

      print(
          'ShiftService: Found ${activeShiftsSnapshot.docs.length} total active shifts');
      print(
          'ShiftService: Found ${otherActiveShifts.length} other active shifts');

      if (otherActiveShifts.isNotEmpty) {
        print('ShiftService: ❌ Teacher has another active shift');
        for (var otherShift in otherActiveShifts) {
          print('ShiftService: Other active shift: ${otherShift.id}');
        }
        return false;
      }

      print('ShiftService: ✅ No conflicting active shifts');

      // Perform clock-in
      final now = DateTime.now();
      print('ShiftService: Performing clock-in update...');

      // Update shift with clock-in time and set status to active if not already
      final updateData = <String, dynamic>{
        'last_modified': Timestamp.fromDate(now),
      };

      // Only set status to active on first clock-in, don't update clock times for subsequent sessions
      if (shift.status != ShiftStatus.active) {
        print('ShiftService: Setting shift status to active (first clock-in)');
        updateData['status'] = ShiftStatus.active.name;
        updateData['clock_in_time'] = Timestamp.fromDate(now);
      } else {
        print('ShiftService: Shift already active (subsequent clock-in)');
        // Clear previous clock_out_time so UI recognises that the teacher is clocked-in again
        updateData['clock_out_time'] = null;
      }
      // For subsequent clock-ins during the same shift, don't modify clock_in_time

      await _shiftsCollection.doc(shiftId).update(updateData);

      print('ShiftService: ✅ Clock-in successful at $now');
      return true;
    } catch (e) {
      print('ShiftService: ❌ Exception during clock-in: $e');
      return false;
    }
  }

  /// Clock out from a shift
  static Future<bool> clockOut(String teacherId, String shiftId) async {
    try {
      print(
          'ShiftService: Attempting clock-out for teacher $teacherId, shift $shiftId');

      final doc = await _shiftsCollection.doc(shiftId).get();
      if (!doc.exists) {
        print('Shift not found: $shiftId');
        return false;
      }

      final shift = TeachingShift.fromFirestore(doc);

      // Validation checks
      if (shift.teacherId != teacherId) {
        print(
            'Teacher ID mismatch: expected ${shift.teacherId}, got $teacherId');
        return false;
      }

      // No need to check isClockedIn here, as the timesheet service handles this.
      // This allows multiple clock-outs as long as there's an open timesheet entry.

      // Perform clock-out
      final now = DateTime.now();

      // For multiple sessions, we don't modify the shift's clock_out_time
      // Each timesheet entry tracks its own start/end times
      await _shiftsCollection.doc(shiftId).update({
        'last_modified': Timestamp.fromDate(now),
        // Mark end of the current session so UI knows the user is no longer clocked-in.
        'clock_out_time': Timestamp.fromDate(now),
      });

      print(
          'Clock-out successful at $now (shift remains active for multiple sessions)');
      return true;
    } catch (e) {
      print('Error during clock-out: $e');
      return false;
    }
  }

  /// Check if teacher can clock in to a shift
  static Future<bool> canTeacherClockIn(
      String teacherId, String shiftId) async {
    try {
      final doc = await _shiftsCollection.doc(shiftId).get();
      if (!doc.exists) return false;

      final shift = TeachingShift.fromFirestore(doc);

      // Check if it's the right teacher
      if (shift.teacherId != teacherId) return false;

      // Check if within clock-in window and not already clocked in
      return shift.canClockIn &&
          shift.status == ShiftStatus.scheduled &&
          !shift.isClockedIn;
    } catch (e) {
      print('Error checking clock-in eligibility: $e');
      return false;
    }
  }

  /// Auto-logout expired shifts (for teachers who didn't clock out)
  static Future<void> autoLogoutExpiredShifts() async {
    try {
      final now = DateTime.now();
      final snapshot =
          await _shiftsCollection.where('status', isEqualTo: 'active').get();

      final batch = _firestore.batch();
      int expiredCount = 0;

      for (final doc in snapshot.docs) {
        final shift = TeachingShift.fromFirestore(doc);

        if (shift.needsAutoLogout) {
          // Auto clock-out expired shifts
          batch.update(doc.reference, {
            'status': ShiftStatus.completed.name,
            'clock_out_time': Timestamp.fromDate(shift.clockOutDeadline),
            'last_modified': Timestamp.fromDate(now),
            'is_manual_override': true, // Mark as auto-logout
          });
          expiredCount++;
          print(
              'Auto-logout shift ${shift.id} - teacher clocked in at ${shift.clockInTime} but didn\'t clock out by ${shift.clockOutDeadline}');
        }
      }

      if (expiredCount > 0) {
        await batch.commit();
        print('Auto-logged out $expiredCount expired shifts');
      }
    } catch (e) {
      print('Error auto-logging out expired shifts: $e');
    }
  }

  /// Get shifts that need auto-logout (for monitoring)
  static Future<List<TeachingShift>> getShiftsNeedingAutoLogout() async {
    try {
      final snapshot =
          await _shiftsCollection.where('status', isEqualTo: 'active').get();

      final shifts = snapshot.docs
          .map((doc) => TeachingShift.fromFirestore(doc))
          .where((shift) => shift.needsAutoLogout)
          .toList();

      return shifts;
    } catch (e) {
      print('Error getting shifts needing auto-logout: $e');
      return [];
    }
  }

  /// Get available teachers for shift assignment
  static Future<List<Employee>> getAvailableTeachers() async {
    try {
      print('ShiftService: Querying for teachers...');
      final snapshot = await _firestore
          .collection('users')
          .where('user_type', isEqualTo: 'teacher')
          .where('is_active', isEqualTo: true)
          .get();

      print(
          'ShiftService: Teachers query returned ${snapshot.docs.length} documents');

      if (snapshot.docs.isEmpty) {
        // Try without the is_active filter to see if that's the issue
        print(
            'ShiftService: Retrying teachers query without is_active filter...');
        final retrySnapshot = await _firestore
            .collection('users')
            .where('user_type', isEqualTo: 'teacher')
            .get();
        print(
            'ShiftService: Retry returned ${retrySnapshot.docs.length} teacher documents');

        // Print first few docs for debugging
        for (int i = 0; i < retrySnapshot.docs.length && i < 3; i++) {
          final doc = retrySnapshot.docs[i];
          print('Teacher doc $i: ${doc.data()}');
        }

        return EmployeeDataSource.mapSnapshotToEmployeeList(retrySnapshot);
      }

      return EmployeeDataSource.mapSnapshotToEmployeeList(snapshot);
    } catch (e) {
      print('Error getting available teachers: $e');
      return [];
    }
  }

  /// Get available students for shift assignment
  static Future<List<Employee>> getAvailableStudents() async {
    try {
      print('ShiftService: Querying for students...');
      final snapshot = await _firestore
          .collection('users')
          .where('user_type', isEqualTo: 'student')
          .where('is_active', isEqualTo: true)
          .get();

      print(
          'ShiftService: Students query returned ${snapshot.docs.length} documents');

      if (snapshot.docs.isEmpty) {
        // Try without the is_active filter to see if that's the issue
        print(
            'ShiftService: Retrying students query without is_active filter...');
        final retrySnapshot = await _firestore
            .collection('users')
            .where('user_type', isEqualTo: 'student')
            .get();
        print(
            'ShiftService: Retry returned ${retrySnapshot.docs.length} student documents');

        // Print first few docs for debugging
        for (int i = 0; i < retrySnapshot.docs.length && i < 3; i++) {
          final doc = retrySnapshot.docs[i];
          print('Student doc $i: ${doc.data()}');
        }

        return EmployeeDataSource.mapSnapshotToEmployeeList(retrySnapshot);
      }

      return EmployeeDataSource.mapSnapshotToEmployeeList(snapshot);
    } catch (e) {
      print('Error getting available students: $e');
      return [];
    }
  }

  /// Convert shift time to teacher's timezone
  static DateTime convertToTeacherTimezone(
    DateTime adminTime,
    String teacherTimezone,
  ) {
    // For now, this is a simplified conversion
    // In production, you'd use a proper timezone library like timezone

    // Common timezone offsets (simplified)
    final timezoneOffsets = {
      'UTC': 0,
      'EST': -5, // Eastern Standard Time
      'PST': -8, // Pacific Standard Time
      'AST': 3, // Saudi Arabia Standard Time
      'GMT': 0, // Greenwich Mean Time
      'CET': 1, // Central European Time
    };

    final offset = timezoneOffsets[teacherTimezone] ?? 0;
    return adminTime.add(Duration(hours: offset));
  }

  /// Get shift statistics
  static Future<Map<String, dynamic>> getShiftStatistics() async {
    try {
      final snapshot = await _shiftsCollection.get();
      final shifts =
          snapshot.docs.map((doc) => TeachingShift.fromFirestore(doc)).toList();

      final now = DateTime.now();
      final today = DateTime(now.year, now.month, now.day);
      final tomorrow = today.add(const Duration(days: 1));

      return {
        'total_shifts': shifts.length,
        'scheduled_shifts':
            shifts.where((s) => s.status == ShiftStatus.scheduled).length,
        'active_shifts':
            shifts.where((s) => s.status == ShiftStatus.active).length,
        'completed_shifts':
            shifts.where((s) => s.status == ShiftStatus.completed).length,
        'missed_shifts':
            shifts.where((s) => s.status == ShiftStatus.missed).length,
        'today_shifts': shifts
            .where((s) =>
                s.shiftStart.isAfter(today) && s.shiftStart.isBefore(tomorrow))
            .length,
        'upcoming_shifts': shifts
            .where((s) =>
                s.shiftStart.isAfter(now) && s.status == ShiftStatus.scheduled)
            .length,
      };
    } catch (e) {
      print('Error getting shift statistics: $e');
      return {};
    }
  }

  /// Get all shifts for a specific teacher with timezone conversion
  static Future<List<TeachingShift>> getShiftsForTeacher(
    String teacherId, {
    String? teacherTimezone,
    int? limitDays,
  }) async {
    try {
      print('ShiftService: Getting shifts for teacher $teacherId');

      // Temporarily remove orderBy to avoid index requirement
      var query = _shiftsCollection.where('teacher_id', isEqualTo: teacherId);

      // Optionally limit to upcoming shifts within X days
      if (limitDays != null) {
        final futureLimit = DateTime.now().add(Duration(days: limitDays));
        query = query.where('shift_start',
            isLessThan: Timestamp.fromDate(futureLimit));
      }

      final snapshot = await query.get();
      print('ShiftService: Found ${snapshot.docs.length} shifts for teacher');

      // Debug: Print ALL shift documents for this teacher
      if (snapshot.docs.isNotEmpty) {
        print(
            'ShiftService: All ${snapshot.docs.length} shifts for teacher $teacherId:');
        for (int i = 0; i < snapshot.docs.length; i++) {
          final doc = snapshot.docs[i];
          final data = doc.data() as Map<String, dynamic>;
          print('  ${i + 1}. Shift ID: ${doc.id}');
          print('     Teacher ID: ${data['teacher_id']}');
          print('     Name: ${data['auto_generated_name']}');
          print('     Subject: ${data['subject']}');
          print('     Date: ${data['shift_start']}');
          print('     Recurrence: ${data['recurrence']}');
          print('     Created: ${data['created_at']}');
          print('');
        }

        // Check for duplicates
        final duplicateNames = <String, int>{};
        for (var doc in snapshot.docs) {
          final data = doc.data() as Map<String, dynamic>;
          final name = data['auto_generated_name'] as String? ?? 'Unknown';
          duplicateNames[name] = (duplicateNames[name] ?? 0) + 1;
        }

        print('ShiftService: Duplicate analysis:');
        duplicateNames.forEach((name, count) {
          if (count > 1) {
            print('  - "$name" appears $count times');
          }
        });
      } else {
        print('ShiftService: No shifts found for teacher_id: $teacherId');
      }

      final shifts =
          snapshot.docs.map((doc) => TeachingShift.fromFirestore(doc)).toList();

      // Sort by shift_start since we can't use orderBy in query without index
      shifts.sort((a, b) => a.shiftStart.compareTo(b.shiftStart));

      // Convert to teacher's timezone if specified
      if (teacherTimezone != null) {
        // Note: In a real app, you'd use a proper timezone library like timezone
        // For now, we'll just note the timezone in the shift object
        return shifts
            .map((shift) => shift.copyWith(
                  teacherTimezone: teacherTimezone,
                ))
            .toList();
      }

      return shifts;
    } catch (e) {
      print('Error getting shifts for teacher: $e');
      return [];
    }
  }

  /// Get upcoming shifts for teacher (next 7 days)
  static Future<List<TeachingShift>> getUpcomingShiftsForTeacher(
    String teacherId, {
    String? teacherTimezone,
  }) async {
    return getShiftsForTeacher(
      teacherId,
      teacherTimezone: teacherTimezone,
      limitDays: 7,
    );
  }

  /// Check if teacher has any active shifts right now
  static Future<bool> hasActiveShift(String teacherId) async {
    try {
      final activeShift = await getCurrentActiveShift(teacherId);
      return activeShift != null;
    } catch (e) {
      print('Error checking active shift: $e');
      return false;
    }
  }

  /// Clean up duplicate shifts for a teacher (EMERGENCY FUNCTION)
  static Future<void> cleanupDuplicateShifts(String teacherId) async {
    try {
      print('ShiftService: Starting cleanup for teacher $teacherId');

      final snapshot = await _shiftsCollection
          .where('teacher_id', isEqualTo: teacherId)
          .get();

      print('ShiftService: Found ${snapshot.docs.length} total shifts');

      // Group by auto_generated_name and date
      final shiftGroups = <String, List<QueryDocumentSnapshot>>{};

      for (var doc in snapshot.docs) {
        final data = doc.data() as Map<String, dynamic>;
        final name = data['auto_generated_name'] as String? ?? 'Unknown';
        final date = (data['shift_start'] as Timestamp?)?.toDate();
        final key = '$name-${date?.day}/${date?.month}/${date?.year}';

        if (!shiftGroups.containsKey(key)) {
          shiftGroups[key] = [];
        }
        shiftGroups[key]!.add(doc);
      }

      // Delete duplicates (keep only the first one of each group)
      int deletedCount = 0;
      final batch = _firestore.batch();

      for (var group in shiftGroups.values) {
        if (group.length > 1) {
          print('Found ${group.length} duplicates of same shift');
          // Keep the first one, delete the rest
          for (int i = 1; i < group.length; i++) {
            batch.delete(group[i].reference);
            deletedCount++;
          }
        }
      }

      if (deletedCount > 0) {
        await batch.commit();
        print('ShiftService: Deleted $deletedCount duplicate shifts');
      } else {
        print('ShiftService: No duplicates found to clean up');
      }
    } catch (e) {
      print('Error cleaning up duplicate shifts: $e');
      throw Exception('Failed to cleanup duplicate shifts');
    }
  }
}
